<meta charset="utf8"><style>body,html{margin:0;padding:0;background-color:#000}div{position:absolute;top:0;bottom:0;left:0;right:0}#canvas{width:100%;height:100%;touch-action:none}</style><div><canvas id="canvas"></canvas></div><script>(function () {
    'use strict';

    // Constants

    // The game's desired dimensions in pixels - the actual dimensions can be adjusted
    // slightly by the Viewport module.
    const TARGET_GAME_WIDTH = 240;
    const TARGET_GAME_HEIGHT = 135;

    // Size in pixels of each map tile
    const TILE_SIZE   = 8;

    // Modes (touch vs mouse cursor)
    const INPUT_MODE_TOUCH = 1;
    const INPUT_MODE_MOUSE = 2;
    const TILE_WALL_TOP = 9;
    const TILE_WALL_RIGHT = 10;
    const TILE_WALL_BOTTOM = 11;
    const TILE_WALL_LEFT = 12;
    const TILE_CORNER_OUTER = 13;
    const TILE_CORNER_INNER = 14;
    const TILE_DYNAMIC = 20;

    const TILE_DESCRIPTIONS = [
        'CAVE FLOOR',
        'CAVE FLOOR',
        'CAVE FLOOR',
        '',
        '',
        '',
        'DOOM PIT',
        'DOOM PIT'
    ];

    // Some pre-calculated radian values
    const R0          =   0;
    const R45         =  45 * Math.PI / 180;
    const R90         =  90 * Math.PI / 180;
    const R360        = 360 * Math.PI / 180;

    // Moths must be within this number of pixels of their target
    // to "act" (construct, gather, etc.).
    const ACTION_DISTANCE = 6;

    // Entity behaviors (states)
    const SPAWN     = 1;
    const IDLE      = 2;
    const MOVE      = 3;
    const PICKUP    = 4;
    const DROPOFF   = 5;
    const CONSTRUCT = 6;
    const DEAD      = 9;

    // Additional behaviors (enemies)
    const CHASE     = 11;
    const ATTACK    = 12;

    // Additional behaviors (buildings)
    const WIP       = 21;
    const ONLINE    = 22;

    // Viewport

    /**
     * Viewport
     *
     * Represents the game display (for us, a canvas).
     */
    const Viewport = {
        init() {
            Viewport.canvas = document.getElementById('canvas');
            Viewport.ctx = Viewport.canvas.getContext('2d');
            Viewport.resize(true);
        },

        // Resize the canvas to give us approximately our desired game display size.
        //
        // Rather than attempt to explain it, here's a concrete example:
        //
        //     we start with a desired game dimension:   480x270px
        //          get the actual browser dimensions:  1309x468px
        //          factor in the display's DPI ratio:  2618x936px
        //         now calculate the horizontal scale:       5.45x
        //                     and the vertical scale:       3.46x
        //            our new offical game scaling is:        5.4x
        //       and our official viewport dimensions:   484x173px
        //
        // This approach emphasizes correct aspect ratio and maintains full-window rendering, at
        // the potential cost of limiting visibility of the game itself in either the X or Y axis.
        // If you use this approach, make sure your GUI can "float" (otherwise there may be whole
        // UI elements the player cannot see!).
        resize(force) {
            let dpi = window.devicePixelRatio,
                width = Viewport.canvas.clientWidth,
                height = Viewport.canvas.clientHeight,
                dpiWidth = width * dpi,
                dpiHeight = height * dpi;

            if (
                force ||
                Viewport.canvas.width !== dpiWidth ||
                Viewport.canvas.height !== dpiHeight
            ) {
                Viewport.canvas.width = dpiWidth;
                Viewport.canvas.height = dpiHeight;

                Viewport.scale = ((Math.max(dpiWidth / TARGET_GAME_WIDTH, dpiHeight / TARGET_GAME_HEIGHT) * 10) | 0) / 10;
                Viewport.width = Math.ceil(dpiWidth / Viewport.scale);
                Viewport.height = Math.ceil(dpiHeight / Viewport.scale);
                Viewport.center = {
                    u: (Viewport.width / 2) | 0,
                    v: (Viewport.height / 2) | 0
                };
                Viewport.clientWidth = width;
                Viewport.clientHeight = height;

                // Note: smoothing flag gets reset on every resize by some browsers, which is why
                // we do it here.
                Viewport.ctx.imageSmoothingEnabled = false;
            }

            // We do this every frame, not just on resize, due to browser sometimes "forgetting".
            Viewport.canvas.style.cursor = 'none';
        },

        fillViewportRect() {
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
        }
    };

    /**
     * KeyboardAdapter
     *
     * Maps keyboard inputs to game inputs.
     */
    const KeyboardAdapter = {
        init() {
            KeyboardAdapter.map = {
                KeyW:        Input.Action.UP,
                KeyA:        Input.Action.LEFT,
                KeyS:        Input.Action.DOWN,
                KeyD:        Input.Action.RIGHT,
                ArrowUp:     Input.Action.UP,
                ArrowLeft:   Input.Action.LEFT,
                ArrowDown:   Input.Action.DOWN,
                ArrowRight:  Input.Action.RIGHT,
                Escape:      Input.Action.MENU
            };

            // For keyboard, we support 8-point movement (S, E, SE, etc.)
            KeyboardAdapter.arrowDirections = [
                { x:   R0, y:   R0, m: 0 },
                { x:   R0, y: -R90, m: 1 },
                { x:   R0, y:  R90, m: 1 },
                { x:   R0, y:   R0, m: 0 },
                { x: -R90, y:   R0, m: 1 },
                { x: -R45, y: -R45, m: 1 },
                { x: -R45, y:  R45, m: 1 },
                { x: -R90, y:   R0, m: 1 },
                { x:  R90, y:   R0, m: 1 },
                { x:  R45, y: -R45, m: 1 },
                { x:  R45, y:  R45, m: 1 },
                { x:  R90, y:   R0, m: 1 },
                { x:   R0, y:   R0, m: 0 },
                { x:   R0, y: -R90, m: 1 },
                { x:   R0, y:  R90, m: 1 },
                { x:   R0, y:   R0, m: 0 }
            ];

            KeyboardAdapter.held = [];

            window.addEventListener('keydown', event => {
                let k = KeyboardAdapter.map[event.code];
                // Debugging - key presses
                // console.log(event.key, event.keyCode, event.code, k);
                if (k) {
                    KeyboardAdapter.held[k] = true;
                }
            });

            window.addEventListener('keyup', event => {
                let k = KeyboardAdapter.map[event.code];
                if (k) {
                    KeyboardAdapter.held[k] = false;
                }
            });

            KeyboardAdapter.reset();
        },

        update() {
            // For keyboards, we want to convert the state of the various arrow keys being held down
            // into a directional vector. We use the browser's event to handle the held state of
            // the other action buttons, so we don't need to process them here.
            let state =
                (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
                (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
                (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
                (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);

            KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
        },

        reset() {
            KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[0];
            for (let action of Object.values(Input.Action)) {
                KeyboardAdapter.held[action] = false;
            }
        }
    };

    /*

    ZzFX - Zuper Zmall Zound Zynth v1.1.8
    By Frank Force 2019
    https://github.com/KilledByAPixel/ZzFX

    ZzFX Features

    - Tiny synth engine with 20 controllable parameters.
    - Play sounds via code, no need for sound assed files!
    - Compatible with most modern web browsers.
    - Small code footprint, the micro version is under 1 kilobyte.
    - Can produce a huge variety of sound effect types.
    - Sounds can be played with a short call. zzfx(...[,,,,.1,,,,9])
    - A small bit of randomness appied to sounds when played.
    - Use ZZFX.GetNote to get frequencies on a standard diatonic scale.
    - Sounds can be saved out as wav files for offline playback.
    - No additional libraries or dependencies are required.

    */

    // zzfx object with some extra functionalty
    const ZZFX = {
        // master volume scale
        volume: .3,

        // sample rate for audio
        sampleRate: 44100,

        // create shared audio context
        x: new (window.AudioContext || webkitAudioContext),

        destination: undefined,

        // play a sound from zzfx paramerters
        play: function(...parameters)
        {
            // build samples and start sound
            return this.playSamples(this.buildSamples(...parameters));
        },

        // play an array of samples
        playSamples: function(...samples)
        {
            // create buffer and source
            const buffer = this.x.createBuffer(samples.length, samples[0].length, this.sampleRate),
                source = this.x.createBufferSource();

            samples.map((d,i)=> buffer.getChannelData(i).set(d));
            source.buffer = buffer;
            source.connect(this.destination);
            source.start();
            return source;
        },

        // build an array of samples
        buildSamples: function
        (
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            sustain = 0,
            release = .1,
            shape = 0,
            shapeCurve = 1,
            slide = 0,
            deltaSlide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            modulation = 0,
            bitCrush = 0,
            delay = 0,
            sustainVolume = 1,
            decay = 0,
            tremolo = 0
        )
        {
            // init parameters
            const PI2 = Math.PI*2;
            let sampleRate = this.sampleRate,
            sign = v => v>0?1:-1,
            startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,
            startFrequency = frequency *=
                (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate,
            b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;

            // scale by sample rate
            attack = attack * sampleRate + 9; // minimum attack to prevent pop
            decay *= sampleRate;
            sustain *= sampleRate;
            release *= sampleRate;
            delay *= sampleRate;
            deltaSlide *= 500 * PI2 / sampleRate**3;
            modulation *= PI2 / sampleRate;
            pitchJump *= PI2 / sampleRate;
            pitchJumpTime *= sampleRate;
            repeatTime = repeatTime * sampleRate | 0;

            // generate waveform
            for(length = attack + decay + sustain + release + delay | 0;
                i < length; b[i++] = s)
            {
                if (!(++c%(bitCrush*100|0)))                      // bit crush
                {
                    s = shape? shape>1? shape>2? shape>3?         // wave shape
                        Math.sin((t%PI2)**3) :                    // 4 noise
                        Math.max(Math.min(Math.tan(t),1),-1):     // 3 tan
                        1-(2*t/PI2%2+2)%2:                        // 2 saw
                        1-4*Math.abs(Math.round(t/PI2)-t/PI2):    // 1 triangle
                        Math.sin(t);                              // 0 sin

                    s = (repeatTime ?
                            1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo
                            : 1) *
                        sign(s)*(Math.abs(s)**shapeCurve) *       // curve 0=square, 2=pointy
                        volume * this.volume * (                  // envelope
                        i < attack ? i/attack :                   // attack
                        i < attack + decay ?                      // decay
                        1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff
                        i < attack  + decay + sustain ?           // sustain
                        sustainVolume :                           // sustain volume
                        i < length - delay ?                      // release
                        (length - i - delay)/release *            // release falloff
                        sustainVolume :                           // release volume
                        0);                                       // post release

                    s = delay ? s/2 + (delay > i ? 0 :            // delay
                        (i<length-delay? 1 : (length-i)/delay) *  // release delay
                        b[i-delay|0]/2) : s;                      // sample delay
                }

                f = (frequency += slide += deltaSlide) *          // frequency
                    Math.cos(modulation*tm++);                    // modulation
                t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise

                if (j && ++j > pitchJumpTime)       // pitch jump
                {
                    frequency += pitchJump;         // apply pitch jump
                    startFrequency += pitchJump;    // also apply to start
                    j = 0;                          // stop pitch jump time
                }

                if (repeatTime && !(++r % repeatTime)) // repeat
                {
                    frequency = startFrequency;     // reset frequency
                    slide = startSlide;             // reset slide
                    j = j || 1;                     // reset pitch jump time
                }
            }

            return b;
        },

        // get frequency of a musical note on a diatonic scale
        getNote: function(semitoneOffset=0, rootNoteFrequency=440)
        {
            return rootNoteFrequency * 2**(semitoneOffset/12);
        }

    }; // ZZFX

    /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
    *
    * Copyright (c) 2011-2013 Marcus Geelnard
    *
    * This software is provided 'as-is', without any express or implied
    * warranty. In no event will the authors be held liable for any damages
    * arising from the use of this software.
    *
    * Permission is granted to anyone to use this software for any purpose,
    * including commercial applications, and to alter it and redistribute it
    * freely, subject to the following restrictions:
    *
    * 1. The origin of this software must not be misrepresented; you must not
    *    claim that you wrote the original software. If you use this software
    *    in a product, an acknowledgment in the product documentation would be
    *    appreciated but is not required.
    *
    * 2. Altered source versions must be plainly marked as such, and must not be
    *    misrepresented as being the original software.
    *
    * 3. This notice may not be removed or altered from any source
    *    distribution.
    *
    */

    // Some general notes and recommendations:
    //  * This code uses modern ECMAScript features, such as ** instead of
    //    Math.pow(). You may have to modify the code to make it work on older
    //    browsers.
    //  * If you're not using all the functionality (e.g. not all oscillator types,
    //    or certain effects), you can reduce the size of the player routine even
    //    further by deleting the code.


    const CPlayer = function() {

        //--------------------------------------------------------------------------
        // Private methods
        //--------------------------------------------------------------------------

        // Oscillators
        var osc_sin = function (value) {
            return Math.sin(value * 6.283184);
        };

        var osc_saw = function (value) {
            return 2 * (value % 1) - 1;
        };

        var osc_square = function (value) {
            return (value % 1) < 0.5 ? 1 : -1;
        };

        var osc_tri = function (value) {
            var v2 = (value % 1) * 4;
            if(v2 < 2) return v2 - 1;
            return 3 - v2;
        };

        var getnotefreq = function (n) {
            // 174.61.. / 44100 = 0.003959503758 (F3)
            return 0.003959503758 * (2 ** ((n - 128) / 12));
        };

        var createNote = function (instr, n, rowLen) {
            var osc1 = mOscillators[instr.i[0]],
                o1vol = instr.i[1],
                o1xenv = instr.i[3]/32,
                osc2 = mOscillators[instr.i[4]],
                o2vol = instr.i[5],
                o2xenv = instr.i[8]/32,
                noiseVol = instr.i[9],
                attack = instr.i[10] * instr.i[10] * 4,
                sustain = instr.i[11] * instr.i[11] * 4,
                release = instr.i[12] * instr.i[12] * 4,
                releaseInv = 1 / release,
                expDecay = -instr.i[13]/16,
                arp = instr.i[14],
                arpInterval = rowLen * (2 **(2 - instr.i[15]));

            var noteBuf = new Int32Array(attack + sustain + release);

            // Re-trig oscillators
            var c1 = 0, c2 = 0;

            // Local variables.
            var j, j2, e, rsample, o1t, o2t;

            // Generate one note (attack + sustain + release)
            for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
                if (j2 >= 0) {
                    // Switch arpeggio note.
                    arp = (arp >> 8) | ((arp & 255) << 4);
                    j2 -= arpInterval;

                    // Calculate note frequencies for the oscillators
                    o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                    o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
                }

                // Envelope
                e = 1;
                if (j < attack) {
                    e = j / attack;
                } else if (j >= attack + sustain) {
                    e = (j - attack - sustain) * releaseInv;
                    e = (1 - e) * (3 ** (expDecay * e));
                }

                // Oscillator 1
                c1 += o1t * e ** o1xenv;
                rsample = osc1(c1) * o1vol;

                // Oscillator 2
                c2 += o2t * e ** o2xenv;
                rsample += osc2(c2) * o2vol;

                // Noise oscillator
                if (noiseVol) {
                    rsample += (2 * Math.random() - 1) * noiseVol;
                }

                // Add to (mono) channel buffer
                noteBuf[j] = (80 * rsample * e) | 0;
            }

            return noteBuf;
        };


        //--------------------------------------------------------------------------
        // Private members
        //--------------------------------------------------------------------------

        // Array of oscillator functions
        var mOscillators = [
            osc_sin,
            osc_square,
            osc_saw,
            osc_tri
        ];

        // Private variables set up by init()
        var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;


        //--------------------------------------------------------------------------
        // Initialization
        //--------------------------------------------------------------------------

        this.init = function (song) {
            // Define the song
            mSong = song;

            // Init iteration state variables
            mLastRow = song.endPattern;
            mCurrentCol = 0;

            // Prepare song info
            mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

            // Create work buffer (initially cleared)
            mMixBuf = new Int32Array(mNumWords);
        };


        //--------------------------------------------------------------------------
        // Public methods
        //--------------------------------------------------------------------------

        // Generate audio data for a single track
        this.generate = function () {
            // Local variables
            var i, j, p, row, col, n, cp,
                k, t, rsample, rowStartSample, f;

            // Put performance critical items in local variables
            var chnBuf = new Int32Array(mNumWords),
                instr = mSong.songData[mCurrentCol],
                rowLen = mSong.rowLen,
                patternLen = mSong.patternLen;

            // Clear effect state
            var low = 0, band = 0, high;
            var lsample, filterActive = false;

            // Clear note cache.
            var noteCache = [];

             // Patterns
             for (p = 0; p <= mLastRow; ++p) {
                cp = instr.p[p];

                // Pattern rows
                for (row = 0; row < patternLen; ++row) {
                    // Execute effect command.
                    var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                    if (cmdNo) {
                        instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                        // Clear the note cache since the instrument has changed.
                        if (cmdNo < 17) {
                            noteCache = [];
                        }
                    }

                    // Put performance critical instrument properties in local variables
                    var oscLFO = mOscillators[instr.i[16]],
                        lfoAmt = instr.i[17] / 512,
                        lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                        fxLFO = instr.i[19],
                        fxFilter = instr.i[20],
                        fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                        q = 1 - instr.i[22] / 255,
                        dist = instr.i[23] * 1e-5,
                        drive = instr.i[24] / 32,
                        panAmt = instr.i[25] / 512,
                        panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                        dlyAmt = instr.i[27] / 255,
                        dly = instr.i[28] * rowLen & ~1;  // Must be an even number

                    // Calculate start sample number for this row in the pattern
                    rowStartSample = (p * patternLen + row) * rowLen;

                    // Generate notes for this pattern row
                    for (col = 0; col < 4; ++col) {
                        n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                        if (n) {
                            if (!noteCache[n]) {
                                noteCache[n] = createNote(instr, n, rowLen);
                            }

                            // Copy note from the note cache
                            var noteBuf = noteCache[n];
                            for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                              chnBuf[i] += noteBuf[j];
                            }
                        }
                    }

                    // Perform effects for this pattern row
                    for (j = 0; j < rowLen; j++) {
                        // Dry mono-sample
                        k = (rowStartSample + j) * 2;
                        rsample = chnBuf[k];

                        // We only do effects if we have some sound input
                        if (rsample || filterActive) {
                            // State variable filter
                            f = fxFreq;
                            if (fxLFO) {
                                f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                            }
                            f = 1.5 * Math.sin(f);
                            low += f * band;
                            high = q * (rsample - band) - low;
                            band += f * high;
                            rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                            // Distortion
                            if (dist) {
                                rsample *= dist;
                                rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                                rsample /= dist;
                            }

                            // Drive
                            rsample *= drive;

                            // Is the filter active (i.e. still audiable)?
                            filterActive = rsample * rsample > 1e-5;

                            // Panning
                            t = Math.sin(panFreq * k) * panAmt + 0.5;
                            lsample = rsample * (1 - t);
                            rsample *= t;
                        } else {
                            lsample = 0;
                        }

                        // Delay is always done, since it does not need sound input
                        if (k >= dly) {
                            // Left channel = left + right[-p] * t
                            lsample += chnBuf[k-dly+1] * dlyAmt;

                            // Right channel = right + left[-p] * t
                            rsample += chnBuf[k-dly] * dlyAmt;
                        }

                        // Store in stereo channel buffer (needed for the delay effect)
                        chnBuf[k] = lsample | 0;
                        chnBuf[k+1] = rsample | 0;

                        // ...and add to stereo mix buffer
                        mMixBuf[k] += lsample | 0;
                        mMixBuf[k+1] += rsample | 0;
                    }
                }
            }

            // Next iteration. Return progress (1.0 == done!).
            mCurrentCol++;
            return mCurrentCol / mSong.numChannels;
        };

        // Create a AudioBuffer from the generated audio data
        this.createAudioBuffer = function(context) {
            var buffer = context.createBuffer(2, mNumWords / 2, 44100);
            for (var i = 0; i < 2; i ++) {
                var data = buffer.getChannelData(i);
                for (var j = i; j < mNumWords; j += 2) {
                    data[j >> 1] = mMixBuf[j] / 65536;
                }
            }
            return buffer;
        };

        // Create a WAVE formatted Uint8Array from the generated audio data
        this.createWave = function() {
            // Create WAVE header
            var headerLen = 44;
            var l1 = headerLen + mNumWords * 2 - 8;
            var l2 = l1 - 36;
            var wave = new Uint8Array(headerLen + mNumWords * 2);
            wave.set(
                [82,73,70,70,
                 l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
                 87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
                 68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
                 l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
            );

            // Append actual wave data
            for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
                // Note: We clamp here
                var y = mMixBuf[i];
                y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
                wave[idx++] = y & 255;
                wave[idx++] = (y >> 8) & 255;
            }

            // Return the WAVE formatted typed array
            return wave;
        };

        // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
        this.getData = function(t, n) {
            var i = 2 * Math.floor(t * 44100);
            var d = new Array(n);
            for (var j = 0; j < 2*n; j += 1) {
                var k = i + j;
                d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
            }
            return d;
        };
    };

    // Song: WindyCave

    // This music has been exported by SoundBox. You can use it with
    // http://sb.bitsnbites.eu/player-small.js in your own product.

    // See http://sb.bitsnbites.eu/demo.html for an example of how to
    // use it in a demo.

    // Song data
    const song = {
        songData: [
          { // Instrument 0
            i: [
            2, // OSC1_WAVEFORM
            138, // OSC1_VOL
            116, // OSC1_SEMI
            0, // OSC1_XENV
            2, // OSC2_WAVEFORM
            138, // OSC2_VOL
            128, // OSC2_SEMI
            4, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            47, // ENV_ATTACK
            48, // ENV_SUSTAIN
            162, // ENV_RELEASE
            63, // ENV_EXP_DECAY
            124, // ARP_CHORD
            3, // ARP_SPEED
            0, // LFO_WAVEFORM
            139, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            3, // FX_FILTER
            64, // FX_FREQ
            160, // FX_RESONANCE
            3, // FX_DIST
            32, // FX_DRIVE
            147, // FX_PAN_AMT
            4, // FX_PAN_FREQ
            121, // FX_DELAY_AMT
            5 // FX_DELAY_TIME
            ],
            // Patterns
            p: [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2],
            // Columns
            c: [
              {n: [123,,,,,,,,,,,,,,,,129],
                f: []},
              {n: [128,,,,,,,,,,,,,,,,126],
                f: []}
            ]
          },
          { // Instrument 1
            i: [
            0, // OSC1_WAVEFORM
            214, // OSC1_VOL
            104, // OSC1_SEMI
            64, // OSC1_XENV
            0, // OSC2_WAVEFORM
            204, // OSC2_VOL
            104, // OSC2_SEMI
            0, // OSC2_DETUNE
            64, // OSC2_XENV
            229, // NOISE_VOL
            4, // ENV_ATTACK
            40, // ENV_SUSTAIN
            43, // ENV_RELEASE
            51, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            231, // LFO_AMT
            6, // LFO_FREQ
            1, // LFO_FX_FREQ
            3, // FX_FILTER
            183, // FX_FREQ
            15, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            232, // FX_PAN_AMT
            4, // FX_PAN_FREQ
            74, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,5,5,5,5,5,5,,,5,5,5,5],
            // Columns
            c: [
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [,,,,,,,,,,,,147,147,,,,,,,,,147,,,,,,,,,,,,,,,,,,,,,,,,150,,,,,,,,,,150],
                f: []}
            ]
          },
          { // Instrument 2
            i: [
            0, // OSC1_WAVEFORM
            255, // OSC1_VOL
            106, // OSC1_SEMI
            64, // OSC1_XENV
            0, // OSC2_WAVEFORM
            255, // OSC2_VOL
            106, // OSC2_SEMI
            0, // OSC2_DETUNE
            64, // OSC2_XENV
            0, // NOISE_VOL
            5, // ENV_ATTACK
            7, // ENV_SUSTAIN
            164, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            2, // FX_FILTER
            255, // FX_FREQ
            0, // FX_RESONANCE
            2, // FX_DIST
            32, // FX_DRIVE
            83, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            25, // FX_DELAY_AMT
            1 // FX_DELAY_TIME
            ],
            // Patterns
            p: [6,6,6,6,6,6,6,6,,,6,6,6,6],
            // Columns
            c: [
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [,,,,,,,,,,,,,,,,,,,,,,,,,141],
                f: []}
            ]
          },
          { // Instrument 3
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            140, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            140, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            255, // NOISE_VOL
            158, // ENV_ATTACK
            158, // ENV_SUSTAIN
            158, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            51, // LFO_AMT
            2, // LFO_FREQ
            1, // LFO_FX_FREQ
            2, // FX_FILTER
            58, // FX_FREQ
            239, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            88, // FX_PAN_AMT
            1, // FX_PAN_FREQ
            157, // FX_DELAY_AMT
            2 // FX_DELAY_TIME
            ],
            // Patterns
            p: [3,4,3,4,3,4,3,4,,,3,4,3,4],
            // Columns
            c: [
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [,,,,123],
                f: []},
              {n: [,,,,128],
                f: []}
            ]
          },
          { // Instrument 4
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            140, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            140, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            81, // NOISE_VOL
            4, // ENV_ATTACK
            10, // ENV_SUSTAIN
            47, // ENV_RELEASE
            55, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            187, // LFO_AMT
            5, // LFO_FREQ
            0, // LFO_FX_FREQ
            1, // FX_FILTER
            239, // FX_FREQ
            135, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            108, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            16, // FX_DELAY_AMT
            4 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,,,7,7,7,7,,,7,7,7,7],
            // Columns
            c: [
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [],
                f: []},
              {n: [,135,,135,,,123,,,,,,,135,,135,,,123,,,,,135,,135,,,124],
                f: []}
            ]
          },
        ],
        rowLen: 10500,   // In sample lengths
        patternLen: 32,  // Rows per pattern
        endPattern: 15,  // End pattern
        numChannels: 5  // Number of channels
      };

    // Audio

    const Audio = {
        init() {
            Audio.readyToPlay = false;

            Audio.towerShoot = [1.01,,1250,.01,.09,.14,,1.77,-6.3,,,,,,23,,,.46,.02];
            Audio.mothDeath = [1.04,,363,.01,.08,.52,2,.31,.3,,,,,1.5,,.9,,.34,.07];
            Audio.ghostDeath = [2.01,,332,.02,.05,.16,1,.53,-0.8,,-7,.01,,.1,,,.03,.48,.04];
            Audio.buildingFinished = [2.03,0,65.40639,.03,.66,.18,2,.95,,,,,.3,.4,,,.19,.21,.1,.04];
            Audio.waveCountdown = [1.56,0,261.6256,,.13,.3,,.41,,,,,,.2,,,.05,.2,.19,.22];
            Audio.tile = [1.68,,0,.01,.01,0,,1.83,-28,-7,,,,,,,.02,,.01];
        },

        update() {
            if (!Audio.readyToPlay) return;

            // This is goofy, but unfortunately we cannot generate our audio buffer until
            // after a user clicks when in Safari. (I'll try to find a more elegant solution
            // for this in the future.)
            if (!Audio.musicPlaying) {
                if (!this.player) {
                    this.player = new CPlayer();
                    this.player.init(song);
                }

                if (this.player.generate() === 1) {
                    let buffer = this.player.createAudioBuffer(Audio.ctx);
                    this.songSource = Audio.ctx.createBufferSource();
                    this.songSource.buffer = buffer;
                    this.songSource.loop = true;
                    this.songSource.connect(Audio.gain_);
                    this.songSource.start();
                    Audio.musicPlaying = true;
                }
            }
        },

        play(sound) {
            if (!Audio.readyToPlay) return;
            ZZFX.play(...sound);
        },

        markReady() {
            if (Audio.readyToPlay) return;

            // In Safari, ensure our target AudioContext is created inside a
            // click or tap event (this ensures we don't interact with it until
            // after user input).
            //
            // Chrome and Firefox are more relaxed, but this approach works for all 3.
            ZZFX.x = Audio.ctx = new AudioContext();
            Audio.gain_ = Audio.ctx.createGain();
            Audio.gain_.connect(Audio.ctx.destination);
            ZZFX.destination = Audio.gain_;

            Audio.readyToPlay = true;
        },

        // It's important we do pausing and unpausing as specific events and not in general update(),
        // because update() is triggered by the animation frame trigger which does not run if the
        // page is not visible. (So, if you want the music to fade in the background, for example,
        // that's not helpful if it won't work because you aren't looking at the page!)

        pause() {
            Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
        },

        unpause() {
            Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
        }
    };

    // MouseAdapter

    /**
     * MouseAdapter
     *
     * Maps mouse inputs to game inputs.
     */
    const MouseAdapter = {
        init() {
            this.map = [];
            this.map[0] = Input.Action.RAW_TOUCH; // LMB
            this.map[2] = Input.Action.RELOAD; // RMB

            this.held = [];

            window.addEventListener('mousemove', event => {
                if (!this.pointer) this.pointer = {};
                this.pointer.u = ((event.clientX * Viewport.width) / Viewport.clientWidth) | 0;
                this.pointer.v = ((event.clientY * Viewport.height) / Viewport.clientHeight) | 0;
                Input.mode = INPUT_MODE_MOUSE;
            });

            window.addEventListener('mouseout', () => {
                this.pointer = undefined;
            });

            window.addEventListener('mousedown', event => {
                let k = this.map[event.button];
                if (k) this.held[k] = true;

                // Hack to ensure we initialize audio after user interacts with game
                Audio.markReady();
                Input.mode = INPUT_MODE_MOUSE;

                this.pointerDragStart = {
                    u: ((event.clientX * Viewport.width) / Viewport.clientWidth) | 0,
                    v: ((event.clientY * Viewport.height) / Viewport.clientHeight) | 0
                };
            });

            window.addEventListener('mouseup', event => {
                let k = this.map[event.button];
                if (k) this.held[k] = false;
                Input.mode = INPUT_MODE_MOUSE;
            });

            window.addEventListener('click', event => {
                event.preventDefault();
                game.frogger = 'click';
            });

            window.addEventListener('contextmenu', event => {
                let k = this.map[event.button];
                if (k) this.held[k] = true;
                this.releaseRMBTick = 2;
                event.preventDefault();
            });

            MouseAdapter.reset();
        },

        update() {
            // Hacks: ideally we could use mousedown and mouseup for all clicks and preventDefault to
            // avoid opening the browser's context menu. This hasn't worked for me so far when clicking
            // on a canvas, so I need to use the context menu event to capture a right mouse click instead.
            //
            // We fake a down/up for RMB clicks, which means we can't determine how long the RMB is held
            // (but luckily we don't need to for this game).
            if (this.releaseRMBTick) {
                this.releaseRMBTick--;
                if (this.releaseRMBTick === 0) {
                    this.held[Input.Action.RELOAD] = false;
                }
            }
        },

        reset() {
            this.pointer = undefined;
            for (let action of Object.values(Input.Action)) {
                this.held[action] = false;
            }
        }
    };

    // TouchAdapter

    /**
     * TouchAdapter
     *
     * Maps touch inputs to game inputs.
     */
    const TouchAdapter = {
        init() {
            this.map = [];
            this.map[0] = Input.Action.RAW_TOUCH;

            this.held = [];

            window.addEventListener('touchmove', event => {
                if (!this.pointer) this.pointer = {};
                let p = event.changedTouches[0];
                this.pointer.u = ((p.clientX * Viewport.width) / Viewport.clientWidth) | 0;
                this.pointer.v = ((p.clientY * Viewport.height) / Viewport.clientHeight) | 0;
                Input.mode = INPUT_MODE_TOUCH;
            });

            window.addEventListener('touchstart', event => {
                let k = this.map[0];
                if (k) this.held[k] = true;

                // Hack to ensure we initialize audio after user interacts with game
                Audio.markReady();
                Input.mode = INPUT_MODE_TOUCH;

                let p = event.changedTouches[0];
                this.pointerDragStart = {
                    u: ((p.clientX * Viewport.width) / Viewport.clientWidth) | 0,
                    v: ((p.clientY * Viewport.height) / Viewport.clientHeight) | 0
                };
                this.pointer = { ...this.pointerDragStart };
            });

            window.addEventListener('touchend', event => {
                let k = this.map[0];
                if (k) this.held[k] = false;
                game.frogger = 'TOUCHEND';
                Input.mode = INPUT_MODE_TOUCH;
            });

            this.reset();
        },

        update() {
        },

        reset() {
            this.pointer = undefined;
            for (let action of Object.values(Input.Action)) {
                this.held[action] = false;
            }
        }
    };

    // Input

    /**
     * This is our abstract game input handler.
     *
     * Each frame, we'll collect input data from all of our supported input adapters,
     * and turn it into game input. This game input can then be used by the game
     * update for the frame.
     *
     * The input adapters give us data like "key X pressed", or "right mouse button
     * clicked", or "button B" pressed, and these are translated into a game input
     * like "dodge".
     */
    const Input = {
        // Game Inputs
        //
        // Note that moving the player around is actually not considered an action; it's
        // a separate non-action input called "direction". It just so happens that on
        // keyboard, for example, pressing the "down arrow" key is considered both a
        // press of the in-game DOWN action and a directional input. It's up to the input
        // consumer to decide which input is relevant (if any). For example, on a menu,
        // we may consume the DOWN/UP actions to navigate the menu, but ignore directional
        // inputs.
        //
        Action: {
            UP: 11,
            DOWN: 12,
            LEFT: 13,
            RIGHT: 14,
            ATTACK: 21,
            RELOAD: 30,
            MENU: 96,
            MUTE: 97,
            FREEZE: 98,
            RAW_TOUCH: 40,
            DRAG: 41,
            TAP: 42
        },

        init() {
            // A vector representing the direction the user is pressing/facing,
            // separate from pressing and releasing inputs. Treating "direction"
            // separately makes it easier to handle gamepad sticks.
            this.direction = { x: 0, y: 0, m: 0 };

            // "Pressed" means an input was pressed THIS FRAME.
            this.pressed = {};

            // "Released" means an input was released THIS FRAME.
            this.released = {};

            // "Held" means an input is held down. The input was "Pressed" either
            // this frame or in a past frame, and has not been "Released" yet.
            this.held = {};

            // How many frames was this input held down by the player. If [held]
            // is false, it represents how long the input was last held down.
            this.framesHeld = {};

            KeyboardAdapter.init();
            MouseAdapter.init();
            TouchAdapter.init();

            this.mode = INPUT_MODE_TOUCH;

            this.dragging = false;
        },

        update() {
            // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
            // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
            // attacking. For directional input, we instead check whether there's movement on the thumbstick,
            // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

            KeyboardAdapter.update();

            let pointerAdapter = this.mode === INPUT_MODE_MOUSE ? MouseAdapter : TouchAdapter;

            for (let action of Object.values(Input.Action)) {
                let held = pointerAdapter.held[action] || KeyboardAdapter.held[action];
                this.pressed[action] = !this.held[action] && held;
                this.released[action] = this.held[action] && !held;

                if (this.pressed[action]) {
                    this.framesHeld[action] = 1;
                } else if (this.held[action] && held) {
                    this.framesHeld[action]++;
                }

                this.held[action] = held;
            }

            this.pointer = pointerAdapter.pointer;
            this.direction = KeyboardAdapter.direction;
            //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;

            if (this.held[Input.Action.RAW_TOUCH]) {
                if (this.framesHeld[Input.Action.RAW_TOUCH] > 20) {
                    this.dragging = true;
                }

                let diffPixels = Math.abs(pointerAdapter.pointerDragStart.u - pointerAdapter.pointer.u) + Math.abs(pointerAdapter.pointerDragStart.v - pointerAdapter.pointer.v);
                if (diffPixels > 5) {
                    this.dragging = true;
                }
            }

            if (this.dragging && pointerAdapter.pointer) {
                this.dragVector = {
                    x: pointerAdapter.pointer.u - pointerAdapter.pointerDragStart.u,
                    y: pointerAdapter.pointer.v - pointerAdapter.pointerDragStart.v
                };
            }

            if (this.released[Input.Action.RAW_TOUCH]) {
                if (this.dragging) {
                    this.dragging = false;
                } else {
                    this.pressed[Input.Action.TAP] = true;
                    this.framesHeld[Input.Action.TAP] = 1;
                }
            }
        },

        onDown(action) {},
        onUp(action) {},
    };

    const C_WIDTH = 3;
    const C_HEIGHT = 5;

    // Very simple variable-width font implementation. The characters in the font strip
    // are left-aligned in their 3x5 pixel boxes, so in order to have variable width,
    // we just need to note the characters that AREN'T full width. Anything not in
    // this list has full shift (3+1 = 4 pixels).
    const C_SHIFT = {
        10: 0, // LF (\n)
        32: 3, // Space ( )
        33: 3, // Bang (!)
        39: 2, // Apostrophe (')
        44: 3, // Comma (,)
        46: 3, // Period (.)
        73: 2 // I
    };

    const C_ICONS = {};

    /**
     * Text
     *
     * Utilities for drawing text using in-game pixel font.
     */
    const Text = {
        init() {
            Text.white = Sprite.font.img;

            let icons = [
                [101, Sprite.buildings[2]],      // e = Earth
                [102, Sprite.buildings[4]],      // f = Fervor
                //[108, Sprite.icon_mouse_lmb],  // l
                //[114, Sprite.icon_mouse_rmb],  // r
            ];
            for (let icon of icons) {
                C_ICONS[icon[0]] = icon[1];
                C_SHIFT[icon[0]] = icon[1].img.width + 1;
            }

            Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
            Text.black_shadow = recolor(Text.white, rgba(90, 20, 90, 0.15));
            Text.blue = recolor(Text.white, rgba(200, 40, 220, 1));
            Text.blue_shadow = recolor(Text.white, rgba(240, 50, 200, 0.2));
            Text.shadow = recolor(Text.white, rgba(240, 240, 255, 0.25));
            Text.red = recolor(Text.white, rgba(240, 50, 50, 1));

            Text.duotone = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3');
            Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));
        },

        drawText(ctx, text, u, v, scale = 1, font = Text.duotone, shadow) {
            for (let idx = 0; idx < text.length; idx++) {
                let c = text.charCodeAt(idx);
                if (c === 119) {
                    // w
                    font = Text.duotone;
                    continue;
                } else if (c === 114) {
                    // r
                    font = Text.duotone_red;
                    continue;
                }

                if (C_ICONS[c]) {
                    ctx.drawImage(
                        C_ICONS[c].img,
                        u,
                        v - (C_ICONS[c].img.height + 4) / 2
                    );
                } else {
                    let k = (c - 32) * (C_WIDTH + 1);
                    if (shadow) {
                        ctx.drawImage(
                            shadow,
                            k % 180,
                            (k / 180 | 0) * 6,
                            C_WIDTH,
                            C_HEIGHT,
                            u + 1,
                            v + 1,
                            C_WIDTH * scale,
                            C_HEIGHT * scale
                        );
                    }
                    ctx.drawImage(
                        font,
                        k % 180,
                        (k / 180 | 0) * 6,
                        C_WIDTH,
                        C_HEIGHT,
                        u,
                        v,
                        C_WIDTH * scale,
                        C_HEIGHT * scale
                    );
                }
                u += (C_SHIFT[c] || C_WIDTH + 1) * scale;
            }
        },

        /*
        drawRightText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {
            u -= Text.measureWidth(text, scale);
            Text.drawText(ctx, text, u, v, scale, font, shadow);
        },
        */

        drawParagraph(ctx, text, u, v, w, h, scale = 1, font = Text.duotone, shadow) {
            let cu = u,
                cv = v,
                phrases = text.split(' ');

            for (let phrase of phrases) {
                while (phrase[0] === '\n') {
                    phrase = phrase.slice(1);
                    cu = u;
                    cv += (C_HEIGHT + 1) * scale;
                }
                let phraseWidth = Text.measureWidth(phrase, scale);
                if (cu + phraseWidth - u > w) {
                    cu = u;
                    cv += (C_HEIGHT + 1) * scale;
                }
                Text.drawText(ctx, phrase, cu, cv, scale, font, shadow);
                cu += phraseWidth + (C_SHIFT[32] || 4);
            }
        },

        measureWidth(text, scale) {
            return text.split('').reduce((sum, c) => sum + (C_SHIFT[c.charCodeAt(0)] || 4), 0) * scale;
        }
    };

    // Text utility functions


    function recolor(font, color) {
        let canvas = createCanvas(font.width, font.height);
        canvas.ctx.fillStyle = color;
        canvas.ctx.fillRect(0, 0, font.width, font.height);
        canvas.ctx.globalCompositeOperation = 'destination-in';
        canvas.ctx.drawImage(font, 0, 0);
        return canvas.canvas;
    }

    function recolorDuotone(font, topColor, bottomColor, tint) {
        // Note: shortcut assumes that the font image is exactly 2 rows of characters.
        let canvas = createCanvas(font.width, font.height);
        canvas.ctx.fillStyle = bottomColor;
        canvas.ctx.fillRect(0, 0, font.width, font.height);
        canvas.ctx.fillStyle = topColor;
        canvas.ctx.fillRect(0, 0, font.width, 1);
        canvas.ctx.fillRect(0, C_HEIGHT + 1, font.width, 1);
        if (tint) {
            canvas.ctx.fillStyle = tint;
            canvas.ctx.fillRect(0, 0, font.width, font.height);
        }
        canvas.ctx.globalCompositeOperation = 'destination-in';
        canvas.ctx.drawImage(font, 0, 0);
        return canvas.canvas;
    }

    // WorldData
    //
    // This file is generated by `gulp buildAssets`.

    const WorldData =
    /* <generated-data> */
    {
        "floors": [
            {
                "name": "1F",
                "tiles": [
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        14,
                        14,
                        14,
                        3,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        7,
                        7,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        7,
                        8,
                        8,
                        7,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        2,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        2,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        8,
                        8,
                        1,
                        1,
                        1,
                        1,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        3,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        2,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        2,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        2,
                        1,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        14,
                        14,
                        2,
                        1,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        7,
                        8,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        7,
                        1,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        3,
                        14
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        2,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        14,
                        1,
                        7,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        2,
                        14,
                        14,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        2,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        8,
                        1,
                        14,
                        0,
                        14,
                        14,
                        1,
                        1,
                        2,
                        14,
                        14
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        3,
                        1,
                        14,
                        14,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        8,
                        1,
                        14,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        2,
                        14,
                        14,
                        14,
                        1,
                        8,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        1,
                        1,
                        1,
                        1,
                        2,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        2,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        2,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        2,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        14,
                        1,
                        7,
                        1,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0
                    ],
                    [
                        14,
                        1,
                        7,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        8,
                        7,
                        1,
                        1,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        14,
                        14,
                        0
                    ],
                    [
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0
                    ],
                    [
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        7,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        3,
                        1,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0
                    ],
                    [
                        0,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        1,
                        1,
                        8,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0
                    ],
                    [
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0
                    ],
                    [
                        0,
                        14,
                        1,
                        1,
                        1,
                        1,
                        2,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        2,
                        1,
                        14,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0
                    ],
                    [
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        14,
                        14,
                        14,
                        2,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        3,
                        1,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        3,
                        1,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        14,
                        14,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        7,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        1,
                        3,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        14,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                "rooms": [],
                "objects": [
                    {
                        "name": "SPAWN",
                        "x": 42,
                        "y": 11
                    },
                    {
                        "name": "EARTH",
                        "x": 20,
                        "y": 3
                    },
                    {
                        "name": "EXIT",
                        "x": 10,
                        "y": 24
                    },
                    {
                        "name": "EARTH",
                        "x": 41,
                        "y": 25
                    },
                    {
                        "name": "EARTH",
                        "x": 43,
                        "y": 22
                    },
                    {
                        "name": "EARTH",
                        "x": 33,
                        "y": 17
                    },
                    {
                        "name": "EARTH",
                        "x": 40,
                        "y": 6
                    },
                    {
                        "name": "EARTH",
                        "x": 36,
                        "y": 3
                    },
                    {
                        "name": "EARTH",
                        "x": 14,
                        "y": 7
                    },
                    {
                        "name": "EARTH",
                        "x": 31,
                        "y": 13
                    },
                    {
                        "name": "EARTH",
                        "x": 7,
                        "y": 13
                    },
                    {
                        "name": "EARTH",
                        "x": 28,
                        "y": 21
                    }
                ],
                "triggers": [],
                "id": 0
            }
        ],
        "bounds": [
            [
                0,
                0
            ],
            [
                46,
                32
            ]
        ],
        "spawn": [
            42,
            11,
            0
        ]
    }
    /* </generated-data> */
    ;

    class Gore {
        constructor(pos, angle, f) {
            this.pos = { ...pos };
            this.angle = angle;
            this.vel = vector2point(angle2vector(this.angle, f ? 3 : 2));
            this.a = R45;
            this.noClipEntity = true;
            this.f = f;
            this.bounce = true;
            this.radius = 1;
            this.r = 0;
            this.t = -1;
            this.d = this.f === 0 ? 45 : 70;

            // TEMPORARY
            this.noClipWall = true;
        }

        think() {
            if (++this.t === this.d) this.cull = true;
            this.vel.x *= 0.9;
            this.vel.y *= 0.9;
            this.a *= 0.95;
            this.r += this.a;
        }

        draw() {
            Sprite.drawViewportSprite(
                Sprite.gore[this.f],
                this.pos,
                this.r
            );
        }
    }

    Gore.damage = entity => Gore.spray(entity, 8, () => 0);
    Gore.kill = entity => Gore.spray(entity, 16, () => (Math.random() * 2) | 0);
    Gore.spray = (entity, count, cb) => {
        for (let i = 0; i < count * (game.victory ? 2 : 1); i++) {
            let r = Math.random() * entity.radius,
                p = vectorAdd(entity.pos, angle2vector(Math.random() * R360, r));
            game.entities.push(
                new Gore(p, Math.random() * R360, cb())
            );
        }
    };

    /**
     * Monster
     */
    class Moth {
        constructor(pos) {
            this.pos = { ...pos };
            this.target = { ...this.pos };
            this.vel = { x: 0, y: 0 };
            this.hp = 1;
            this.damage = [];
            this.radius = 3;
            this.state = IDLE;
            this.noClipEntity = true;
            this.noClipWall = true;

            this.lightlevel = 7;

            this.tasks = [];
            this.carrying = 0;

            this.offset = { x: 0, y: 0 };

            this.carryAmount = 0;
            this.carryCapacity = 5_00;
            this.carryPerFrame = 3;
            this.transferAmount = 0;

            this.frame = 0;
            this.circleOffset = Math.floor(Math.random() * 16);

            this.lastAssigned = game.frame;

            let qr = xy2qr(this.pos);
            this.moveTo({ q: qr.q, r: qr.r - 1 });
        }

        think() {
            if (this.tasks.length === 0) {
                this.tasks.push({ task: IDLE });
            }
            let task = this.tasks[this.tasks.length - 1];

            this.frame = (Math.floor(game.frame / 8) % 2) + 1;

            if (this.state === DEAD) {
                Audio.play(Audio.mothDeath);
                this.cull = true;
                return;
            }

            if (task.task === MOVE) {
                this.target = centerxy(qr2xy(task.qr));
                let dist = vectorBetween(this.pos, this.target);

                if (dist.m < ACTION_DISTANCE) {
                    this.tasks.pop();
                }
            } else if (task.task === CONSTRUCT) {
                this.target = centerxy(qr2xy(task.qr));
                let dist = vectorBetween(this.pos, this.target);

                if (dist.m < ACTION_DISTANCE) {
                    this.frame = 0;
                    let building = World.buildingAt(task.qr);
                    building.buildFrames++;
                    if (building.buildFrames >= building.buildFramesTotal) {
                        this.tasks.pop();
                    }
                }
            } else if (task.task === PICKUP) {
                this.target = centerxy(qr2xy(task.qr));
                let dist = vectorBetween(this.pos, this.target);

                let building = World.buildingAt(task.qr);

                if (!building) {
                    this.tasks.pop();
                    this.tasks.push({ task: DROPOFF, qr: { q: World.spawn.q, r: World.spawn.r } });
                } else if (dist.m < ACTION_DISTANCE) {
                    this.frame = 0;
                    this.carryAmount += this.carryPerFrame;
                    building.resourcesLeft -= this.carryPerFrame;
                    if (this.carryAmount >= this.carryCapacity) {
                        this.tasks.push({ task: DROPOFF, qr: { q: World.spawn.q, r: World.spawn.r } });
                    }
                }
            } else if (task.task === DROPOFF) {
                this.target = centerxy(qr2xy(task.qr));
                let dist = vectorBetween(this.pos, this.target);

                if (dist.m < ACTION_DISTANCE) {
                    this.frame = 0;

                    this.carryAmount -= this.carryPerFrame;
                    this.transferAmount += this.carryPerFrame;
                    if (this.transferAmount >= 100) {
                        game.earth++;
                        this.transferAmount -= 100;
                    }

                    if (this.carryAmount <= 0) {
                        this.tasks.pop();
                    }
                }
            }

            let pathToTarget = World.pathToTarget(this.pos, this.target);
            let dist = vectorBetween(this.pos, pathToTarget);
            dist.m = clamp(dist.m, 0, 0.5);

            let newVelocity = vector2point(dist);

            this.vel = {
                x: (this.vel.x + newVelocity.x) / 2,
                y: (this.vel.y + newVelocity.y) / 2
            };
        }

        draw() {
            let r = 3;
            if (this.frame === 0) r--;

            let uv = {
                u: Math.cos((game.frame + this.circleOffset) / 16) * r,
                v: Math.sin((game.frame + this.circleOffset) / 16) * 1
            };

            Sprite.drawViewportSprite(Sprite.moth[this.frame], { x: this.pos.x + uv.u, y: this.pos.y + uv.v });

            //Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);
            //Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);
        }

        gather(qr) {
            //this.target = { x: qr.q * 8, y: qr.r * 8 };
            this.tasks = [
                { task: PICKUP, qr: qr }
            ];
            this.lastAssigned = game.frame;
        }

        construct(qr) {
            //this.target = { x: qr.q * 8, y: qr.r * 8 };
            this.tasks.push(
                { task: CONSTRUCT, qr: qr }
            );
            this.lastAssigned = game.frame;
        }

        moveTo(qr) {
            this.tasks = [
                { task: MOVE, qr: qr }
            ];
            this.lastAssigned = game.frame;
        }

        isBusy() {
            let task = this.tasks[this.tasks.length - 1];
            return task && task.task !== IDLE;
        }
    }

    Moth.sortMoths = () => {
        let moths = game.entities.filter(e => e instanceof Moth);
        moths.sort((a, b) => {
            if (a.isBusy() && !b.isBusy()) {
                return 1;
            } else if (!a.isBusy() && b.isBusy()) {
                return -1;
            } else {
                return a.lastAssigned - b.lastAssigned;
            }
        });
        return moths;
    };

    Moth.assign = (fn) => {
        let moths = Moth.sortMoths();

        for (let i = 0; i < moths.length; i++) {
            if (i > 0 && moths[i].isBusy()) break;
            fn(moths[i]);
        }
    };

    class TowerGunk {
        constructor(pos, target, damage) {
            this.pos = { ...pos };
            this.target = target;
            this.vel = { x: 0, y: 0 };
            this.damage = damage || 70;
        }

        think() {
            let diff = vectorBetween(this.pos, this.target.pos);
            diff.m = clamp(diff.m, 0, 2);
            this.vel = {
                x: (this.vel.x + diff.x * diff.m) / 2,
                y: (this.vel.y + diff.y * diff.m) / 2
            };

            if (diff.m < 1) {
                this.target.damage.push({ amount: this.damage, vector: diff, knockback: 1 });
                this.cull = true;
            }

            this.lastpos = this.pos;
        }

        draw() {
            if (this.lastpos) {
                Viewport.ctx.globalAlpha = 0.7;
                Sprite.drawViewportSprite(
                    Sprite.bullet1[0],
                    this.lastpos
                );
                Viewport.ctx.globalAlpha = 1;
            }

            Sprite.drawViewportSprite(
                Sprite.bullet1[0],
                this.pos
            );
        }
    }

    /**
     * Monster
     */
    const BuildTowerAction = {
        defaultTapAction() {
            let building = World.buildingAt(World.selected);
            return !!building;
        },

        buttonSprite() {
            return Sprite.buttons[6];
        },

        buttonSelectedSprite() {
            return Sprite.buttons[7];
        },

        drawSelectedText(u, v) {
            let building = World.buildingAt(World.selected);
            let costs = [15, 0];
            let text = 'BUILD TOWER \n' + game.formatCost(...costs);

            if (building) {
                text = 'FINISH BUILDING';
            }

            Text.drawParagraph(
                Viewport.ctx,
                text,
                u,
                v
            );
        },

        tap() {
            let building = World.buildingAt(World.selected);
            let costs = [15, 0];

            if (building) {
                Moth.assign(moth => moth.construct(World.selected));
            } else if (game.canAfford(...costs)) {
                game.payCost(...costs);
                World.buildings.push(new TowerBuilding(World.selected));
                Moth.assign(moth => moth.construct(World.selected));
                return true;
            }
        }
    };

    /**
     * Monster
     */
    class TowerBuilding {
        constructor(qr) {
            this.qr = { ...qr };
            this.framesToNextShot = 10;

            this.lightlevel = 7;

            this.state = WIP;
            this.buildFrames = 0;
            this.buildFramesTotal = 180;

            this.title = 'TOWER';
            this.portraitSprite = Sprite.buildings[0];
        }

        think() {
            if (this.buildFrames >= this.buildFramesTotal) {
                if (this.state !== ONLINE) {
                    this.state = ONLINE;
                    Audio.play(Audio.buildingFinished);
                }
            } else {
                return;
            }

            let xy = centerxy(qr2xy(this.qr));

            let closestTarget, closestVector;

            if (!this.target || this.target.cull) {
                for (let entity of game.entities) {
                    if (!entity.enemy) continue;

                    //let qr = xy2qr(entity.pos);
                    let v = vectorBetween(xy, entity.pos);
                    if (v.m < 32 && (!closestVector || v.m < closestVector.m)) {
                        closestTarget = entity;
                        closestVector = v;
                    }
                }

                this.target = closestTarget;
            }

            if (this.framesToNextShot > 0) {
                this.framesToNextShot--;
            }

            if (this.target && this.framesToNextShot === 0) {
                vectorBetween(xy, this.target);
                game.entities.push(new TowerGunk({ x: xy.x, y: xy.y - 5 }, this.target));
                this.framesToNextShot = 100;
                Audio.play(Audio.towerShoot);
            }
        }

        draw() {
            let xy = qr2xy(this.qr);
            xy2uv(centerxy(xy));

            //Viewport.ctx.drawImage(Sprite.tiles[tiles[y][x] - 1].img, x * 8 + offset.u, y * 8 + offset.v);

            Viewport.ctx.globalAlpha = this.state === WIP ? 0.5 : 1;
            Sprite.drawViewportSprite(Sprite.buildings[0], xy);
            Viewport.ctx.globalAlpha = 1;

            /*
            Viewport.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            Viewport.ctx.beginPath();
            Viewport.ctx.arc(uv.u, uv.v, 4, 0, 2 * Math.PI * 0.7);
            Viewport.ctx.fill();
            */

            if (this.state === WIP) {
                let progress = clamp(Math.floor(8 * this.buildFrames / this.buildFramesTotal), 0, 7);

                Viewport.ctx.globalAlpha = 0.5;
                Sprite.drawViewportSprite(Sprite.hud_wip[7], xy);
                Viewport.ctx.globalAlpha = 1;
                Sprite.drawViewportSprite(Sprite.hud_wip[progress], xy);
            }

            //Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);
            //Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);
        }

        hudActions() {
            if (this.buildFrames < this.buildFramesTotal) {
                return [BuildTowerAction];
            } else {
                return [];
            }
        }
    }

    const SPAWN_COST_EARTH = [0, 2];
    for (let i = 2; i <= 19; i++) {
        SPAWN_COST_EARTH[i] = Math.floor(SPAWN_COST_EARTH[i - 1] * 1.5 + 1);
    }
    for (let i = 0; i < 20; i++) {
        SPAWN_COST_EARTH[i] = SPAWN_COST_EARTH[i] * 5;
    }

    const SpawnMothAction = {
        defaultTapAction() {
            return false;
        },

        buttonSprite() {
            return Sprite.buttons[0];
        },

        buttonSelectedSprite() {
            return Sprite.buttons[1];
        },

        drawSelectedText(u, v) {
            let costs = [SPAWN_COST_EARTH[game.activeMoths()], 0];
            let text = 'LURE MOTH \n' + game.formatCost(...costs);

            Text.drawParagraph(
                Viewport.ctx,
                text,
                u,
                v
            );
        },

        tap() {
            let costs = [SPAWN_COST_EARTH[game.activeMoths()], 0];

            if (game.canAfford(...costs)) {
                game.payCost(...costs);
                game.entities.push(new Moth(centerxy(qr2xy(World.selected))));
                return true;
            }
        }
    };

    /**
     * Monster
     */
    const TeleportCoffinAction = {
        defaultTapAction() {
            let building = World.buildingAt(World.selected);
            return !!building;
        },

        buttonSprite() {
            return Sprite.buttons[8];
        },

        buttonSelectedSprite() {
            return Sprite.buttons[9];
        },

        drawSelectedText(u, v) {
            let building = World.buildingAt(World.selected);
            let costs = [50, 10];
            let text = 'MOVE COFFIN \n' + game.formatCost(...costs);

            if (building) {
                text = 'FINISH BUILDING';
            }

            Text.drawParagraph(
                Viewport.ctx,
                text,
                u,
                v
            );
        },

        tap() {
            let building = World.buildingAt(World.selected);
            let costs = [50, 10];

            if (building) {
                Moth.assign(moth => moth.construct(World.selected));
            } else if (game.canAfford(...costs)) {
                game.payCost(...costs);
                World.buildings.push(new CoffinBuilding(World.selected));
                Moth.assign(moth => moth.construct(World.selected));
                return true;
            }
        }
    };

    class AttackAnimation {
        constructor(pos) {
            this.pos = { ...pos };
            this.t = -1;
            this.d = 3;
            this.z = 101;
            this.rot = Math.random() * Math.PI * 2;
        }

        think() {
            if (++this.t === this.d) this.cull = true;
            this.rot += 0.1;
        }

        draw() {
            let frame = this.t < 2 ? 0 : 1;
            Sprite.drawViewportSprite(Sprite.attack[frame], this.pos, this.rot);
        }
    }

    /**
     * Monster
     */
    class CoffinBuilding {
        constructor(qr, initialSpawn) {
            this.qr = { ...qr };

            this.state = WIP;
            this.buildFrames = 0;
            this.buildFramesTotal = 180;

            if (initialSpawn) {
                this.buildFrames = 180;
                this.state = ONLINE;
            }

            this.title = 'YOUR COFFIN \nIXNA VALRI';
            this.portraitSprite = Sprite.buildings[1];
            this.lightlevel = 9;
        }

        think() {
            if (this.buildFrames >= this.buildFramesTotal) {
                if (this.state !== ONLINE) {
                    this.state = ONLINE;
                    Audio.play(Audio.buildingFinished);
                    for (let building of World.buildings) {
                        if (building instanceof CoffinBuilding && building !== this) {
                            game.entities.push(new AttackAnimation(centerxy(qr2xy(building.qr))));
                            building.cull = true;
                        }
                    }
                    World.spawn = { ...this.qr };
                }
            } else {
                return;
            }
        }

        draw() {
            let xy = qr2xy(this.qr);

            //Viewport.ctx.drawImage(Sprite.tiles[tiles[y][x] - 1].img, x * 8 + offset.u, y * 8 + offset.v);
            Sprite.drawViewportSprite(Sprite.buildings[1], xy);

            //Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);
            //Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);
            if (this.state === WIP) {
                let progress = clamp(Math.floor(8 * this.buildFrames / this.buildFramesTotal), 0, 7);

                Viewport.ctx.globalAlpha = 0.5;
                Sprite.drawViewportSprite(Sprite.hud_wip[7], xy);
                Viewport.ctx.globalAlpha = 1;
                Sprite.drawViewportSprite(Sprite.hud_wip[progress], xy);
            }
        }

        hudActions() {
            if (this.buildFrames < this.buildFramesTotal) {
                return [TeleportCoffinAction];
            } else {
                return [SpawnMothAction];
            }
        }
    }

    // ghost?

    /**
     * Monster
     */
    class Ghost {
        constructor(pos, variant) {
            this.pos = { ...pos };
            this.damage = [];
            this.vel = { x: 0, y: 0 };
            this.radius = 2;
            this.mass = 0.2;
            this.lastAttack = 0;
            this.state = CHASE;
            this.enemy = true;

            this.variant = variant;

            if (!variant) {
                this.hp = 100;
                this.attackDistance = 8;
                this.moveSpeed = 0.3;
            } else if (variant === 1) {
                this.hp = 300;
                this.attackDistance = 8;
                this.moveSpeed = 0.3;
            } else if (variant === 2) {
                this.hp = 800;
                this.attackDistance = 16;
                this.moveSpeed = 0.1;
            }

            this.maxhp = this.hp;
        }

        think() {
            let targets = game.entities.filter(x => x instanceof Moth);
            let bestTarget = targets[0];

            if (!bestTarget) return;

            let bestDiff = vectorBetween(this.pos, bestTarget.pos);
            for (let i = 1; i < targets.length; i++) {
                let diff = vectorBetween(this.pos, targets[i].pos);
                if (diff.m < bestDiff.m) {
                    bestTarget = targets[i];
                    bestDiff = diff;
                }
            }

            const pathToTarget = World.pathToTarget(this.pos, bestTarget.pos);

            let diff = vectorBetween(this.pos, pathToTarget);

            if (this.state === CHASE) {
                if (bestDiff.m < this.attackDistance) {
                    this.state = ATTACK;
                    this.attackFrames = 10;
                    this.attackTarget = bestTarget;
                } else {
                    diff.m = clamp(diff.m, 0, this.moveSpeed);
                    this.vel = {
                        x: (this.vel.x + diff.x * diff.m) / 2,
                        y: (this.vel.y + diff.y * diff.m) / 2
                    };
                }
            } else if (this.state === ATTACK) {
                this.vel = {
                    x: this.vel.x * 0.9,
                    y: this.vel.y * 0.9
                };
                this.attackFrames--;
                if (this.attackFrames === 5) {
                    this.attackTarget.damage.push({ amount: 10, vector: { x: 0, y: 0, m: 0 }, knockback: 0 });
                } else if (this.attackFrames === -30) {
                    this.state = CHASE;
                }
            } else if (this.state === DEAD) {
                Audio.play(Audio.ghostDeath);
                this.cull = true;
                game.fervor += (this.variant + 1);
                Gore.kill(this);
            }
        }

        draw() {
            //if (!this.lastQR) return;
            let frame = (this.variant * 2) + (this.state === ATTACK ? 1 : 0);
            let sprite = Sprite.ghost[frame];


            /*for (let r = 0; r < this.targetField.length; r++) {
                for (let q = 0; q < this.targetField[0].length; q++) {
                    let uv = xy2uv(qr2xy({ q, r }));
                    Text.drawText(
                        Viewport.ctx,
                        '' + this.targetField[r][q] || '',
                        uv.u,
                        uv.v
                    );
                }
            }*/

            /*
            let uv = xy2uv(qr2xy(this.lastQR));
            Viewport.ctx.fillStyle = rgba(255, 0, 0, 0.2);
            Viewport.ctx.fillRect(uv.u + 1, uv.v + 1, 7, 7);

            uv = xy2uv(qr2xy(this.nextQR));
            Viewport.ctx.fillStyle = rgba(0, 255, 0, 0.2);
            Viewport.ctx.fillRect(uv.u + 1, uv.v + 1, 7, 7);
            */

            /*let sprite = Sprite.stabguts[((game.frame / 12) | 0) % 2];
            this.state === RELOAD && (sprite = Sprite.stabguts[2]);
            this.state === ATTACK && (sprite = Sprite.stabguts[3]);*/
            Sprite.drawViewportSprite(
                sprite,
                this.pos //,
                //this.facingAngle + R90
            );

            if (this.hp < this.maxhp) {
                let hp = Math.ceil(this.hp / this.maxhp * 7);
                if (hp >= 0) {
                    Sprite.drawViewportSprite(
                        Sprite.enemy_healthbar[hp],
                        this.pos
                    );
                }
            }
        }
    }

    // GatherEarthAction

    const GatherEarthAction = {
        defaultTapAction() {
            return true;
        },

        buttonSprite() {
            return Sprite.buttons[2];
        },

        buttonSelectedSprite() {
            return Sprite.buttons[3];
        },

        drawSelectedText(u, v) {
            let text = 'GATHER EARTH';

            Text.drawParagraph(
                Viewport.ctx,
                text,
                u,
                v
            );
        },

        tap() {
            Moth.assign(moth => moth.gather(World.selected));
            return true;
        }
    };

    /**
     * Monster
     */
    class EarthBuilding {
        constructor(qr) {
            this.qr = { ...qr };
            this.resourcesLeft = 150_00;

            this.title = 'EARTH';
            this.portraitSprite = Sprite.buildings[2];
        }

        think() {
            this.title = 'EARTH \n' + Math.ceil(this.resourcesLeft / 100) + ' REMAINING';

            if (this.resourcesLeft < 1) {
                this.cull = true;
            }
        }

        draw() {
            let xy = qr2xy(this.qr);

            //Viewport.ctx.drawImage(Sprite.tiles[tiles[y][x] - 1].img, x * 8 + offset.u, y * 8 + offset.v);
            Sprite.drawViewportSprite(Sprite.buildings[2], xy);

            //Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);
            //Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);
        }

        hudActions() {
            return [GatherEarthAction];
        }
    }

    // GatherEarthAction

    const MoveAction = {
        defaultTapAction() {
            return true;
        },

        buttonSprite() {
            return Sprite.buttons[4];
        },

        buttonSelectedSprite() {
            return Sprite.buttons[5];
        },

        drawSelectedText(u, v) {
            let text = 'EXPLORE';

            Text.drawParagraph(
                Viewport.ctx,
                text,
                u,
                v
            );
        },

        tap() {
            Moth.assign(moth => moth.moveTo(World.selected));
            return true;
        }
    };

    // VictoryScreen

    class VictoryScreen {
        constructor() {
            this.frames = 0;
        }

        update() {
            this.frames++;

            return true;
        }

        draw() {
            //Viewport.ctx.fillStyle = rgba(13, 43, 69, clamp(this.frames / 200, 0, 1));
            Viewport.ctx.fillStyle = rgba(36, 26, 20, clamp(this.frames / 200, 0, 1));
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            let width = Viewport.width - 32;
            let x = 16;
            let y = 16;

            let message = 'ESCAPE! \n' +
                '                    \n' +
                'VILLAGERS STIR UNEASILY IN THEIR BEDS AS YOU EMERGE INTO MOONLIGHT. YOU SENSE WARM BODIES ALL AROUND YOU, RIPE FOR PICKING. IT IS ONLY A MATTER OF TIME NOW BEFORE YOU REGAIN YOUR FULL NECROMANTIC POWER. \n' +
                '                    \n' +
                'CONGRATULATIONS... AND THE END.  ' + game.fervor + 'f';

            message = message.slice(0, this.frames);

            Text.drawParagraph(
                Viewport.ctx,
                message,
                x,
                y,
                width,
                1,
                1
            );
        }
    }

    /**
     * Monster
     */
    class ExitBuilding {
        constructor(qr) {
            this.qr = { ...qr };

            this.title = 'REACH EXIT \nTO ESCAPE';
            this.portraitSprite = Sprite.buildings[3];
            this.lightlevel = 4;
        }

        think() {
            let moths = Moth.sortMoths();
            let pos = centerxy(qr2xy(this.qr));

            for (let moth of moths) {
                let dist = vectorBetween(moth.pos, pos);
                if (dist.m < 2) {
                    game.screen = new VictoryScreen();
                    return;
                }
            }
        }

        draw() {
            let xy = qr2xy(this.qr);

            //Viewport.ctx.drawImage(Sprite.tiles[tiles[y][x] - 1].img, x * 8 + offset.u, y * 8 + offset.v);
            Sprite.drawViewportSprite(Sprite.buildings[3], xy);

            //Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);
            //Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);
        }

        hudActions() {
            return [MoveAction];
        }
    }

    // World

    const World = {
        init() {
            this.reset();
        },

        draw() {
            let tiles = this.floors[0].tiles;
            //console.log(Camera.pos);
            //Camera.pos.x++;
            let offset = xy2uv({ x: 0, y: 0 });

            //console.log(offset);

            for (let r = 0; r < tiles.length; r++) {
                for (let q = 0; q < tiles[0].length; q++) {
                    //Viewport.ctx.globalAlpha = clamp(this.lightmap[y][x] / 5, 0.1, 1);
                    if (tiles[r][q] > 0) {
                        //console.log(x, y, tiles[y][x], Sprite.tiles[tiles[y][x] - 1]);
                       Viewport.ctx.drawImage(Sprite.tiles[tiles[r][q] - 1].img, q * TILE_SIZE + offset.u, r * TILE_SIZE + offset.v);


                       //Text.drawText(Viewport.ctx, '' + this.lightmap[y][x], x * TILE_SIZE + offset.u, y * TILE_SIZE + offset.v);
                    }
                }
            }

            //Viewport.ctx.globalAlpha = 1;

            /*
            if (Game.frame % 133 === 0) {
                //console.log('generating visions');
                this.visions = [];
                for (let i = 0; i < 10; i++) {
                    this.visions.push([
                        Math.floor(Math.random() * tiles[0].length),
                        Math.floor(Math.random() * tiles.length),
                        String.fromCharCode(97 + Math.floor(Math.random() * 26))
                    ]);
                }
            } else if (Game.frame % 133 >= 5 && Game.frame % 133 <= 25) {
                for (let vision of this.visions) {
                    Screen.writeOnMap(vision[0], vision[1], vision[2], Screen.RED);
                }
            }
            */

            for (let building of this.buildings) {
                building.draw();
            }
        },

        drawLightmap() {
            let tiles = this.tiles;
            let offset = xy2uv({ x: 0, y: 0 });

            for (let r = 0; r < tiles.length; r++) {
                for (let q = 0; q < tiles[0].length; q++) {
                    if (tiles[r][q] > 0) {
                        let lightlevel = 1 - clamp(this.lightmap[r][q] / 5, 0.1, 1);
                        if (this.fogofwar[r][q] === 0) lightlevel = 1;

                        Viewport.ctx.globalAlpha = lightlevel;
                        Viewport.ctx.drawImage(Sprite.tile_background[0].img, q * TILE_SIZE + offset.u, r * TILE_SIZE + offset.v);

                        //Viewport.ctx.fillStyle = rgba(36, 26, 20, lightlevel);
                        //Viewport.ctx.fillRect(q * TILE_SIZE + offset.u, r * TILE_SIZE + offset.v, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            Viewport.ctx.globalAlpha = 1;
        },

        reset() {
            // We want to be careful and CLONE (not reference) the world data, because
            // this will be our "working copy" -- rooms and objects and even tiles might
            // get updated and moved during game logic.
            this.floors = WorldData.floors.map(floor => {
                return {
                    tiles: floor.tiles.map(row => [...row]),
                    objects: floor.objects.map(object => ({ ...object })),
                    //objects: floor.objects.map(object => ({ id: object[0], x: object[1], y: object[2], type: object[3] })),
                    // *COMBAT*
                    //triggers: floor.triggers.map(trigger => ({ ...trigger }))
                };
            });
            this.bounds = WorldData.bounds;
            this.spawn = { q: WorldData.spawn[0], r: WorldData.spawn[1] };

            this.buildings = [];
            this.buildings.push(new CoffinBuilding(this.spawn, true));

            for (let b of this.floors[0].objects) {
                if (b.name === 'EARTH') {
                    this.buildings.push(new EarthBuilding({ q: b.x, r: b.y }));
                } else if (b.name === 'EXIT') {
                    this.buildings.push(new ExitBuilding({ q: b.x, r: b.y }));
                    this.exit = { q: b.x, r: b.y };
                }
            }

            this.selected = undefined;

            this.tiles = this.floors[0].tiles;
            this.width = this.tiles[0].length;
            this.height = this.tiles.length;

            this.lightmap = array2d(this.width, this.height, () => 0);
            this.fogofwar = array2d(this.width, this.height, () => 0);

            this.cachedFields = {};

            this.makePrettyWalls();
        },

        update() {
            for (let building of this.buildings) {
                building.think();
            }

            this.updateLightmap();
        },

        canMoveInto(pos) {
            let tile = this.tileAt(pos);
            if (tile === 46 /* . */) return true;
            return false;
        },

        isSeeThrough(pos) {
            return this.SEE_THROUGH.includes(this.floors[pos.z].tiles[pos.y][pos.x]);
        },

        refreshVisible(pos) {
            this.floors[pos.z];
            //FieldOfView.resetVisible(floor.visible);
            //FieldOfView.refreshVisible(pos, floor.visible, floor.seen);
        },

        tap(uv) {
            let qr = xy2qr(uv2xy(uv));
            let tile = this.tileAt(qr);

            if (!tile || tile > 8 || !this.fogofwar[qr.r][qr.q]) {
                this.selected = undefined;
            } else {
                if (this.selected && this.selected.q === qr.q && this.selected.r === qr.r) {
                    let building = this.buildingAt(this.selected);
                    if (building) {
                        let actions = building.hudActions();
                        if (actions[0] && actions[0].defaultTapAction()) {
                            actions[0].tap();
                        }
                    } else {
                        MoveAction.tap();
                    }
                } else {
                    // single tap, reselect
                    this.selected = qr;
                    Audio.play(Audio.tile);
                    this.buildingAt(this.selected);
                    /*if (building) {
                        let actions = building.hudActions();
                        if (actions[0] && actions[0].defaultTapAction) {
                            Hud.selectedAction = actions[0];
                        }
                    }*/
                }
            }
        },

        tileAt(qr) {
            if (qr) {
                return this.floors[0].tiles[qr.r]?.[qr.q];
            }
        },

        buildingAt(qr) {
            if (qr) {
                for (let building of this.buildings) {
                    if (building.qr.q === qr.q && building.qr.r === qr.r) return building;
                }
            }
        },

        updateLightmap() {
            /*
            for (let r = 0; r < this.height; r++) {
                for (let q = 0; q < this.width; q++) {
                    this.lightmap[r][q] = 0;
                }
            }

            for (let b of this.buildings) {
                for (let r = -3; r <= 3; r++) {
                    for (let q = -3; q <= 3; q++) {
                        let diff = 5 - Math.abs(r) - Math.abs(q);
                        if (diff <= 0) continue;

                        let tq = b.qr.q + q, tr = b.qr.r + r;
                        if (tq >= 0 && tr >= 0 && tq < this.width && tr < this.height) {
                            if (this.lightmap[tr][tq] < diff) {
                                this.lightmap[tr][tq] = diff;
                            }
                        }
                    }
                }
            }

            for (let e of game.entities) {
                if (!(e instanceof Moth)) continue;
                let qr = xy2qr(e.pos);
                for (let r = -4; r <= 4; r++) {
                    for (let q = -4; q <= 4; q++) {
                        let diff = 9 - Math.abs(r) - Math.abs(q);
                        if (diff <= 0) continue;

                        let tq = qr.q + q, tr = qr.r + r;
                        if (tq >= 0 && tr >= 0 && tq < this.width && tr < this.height) {
                            if (this.lightmap[tr][tq] < diff) {
                                this.lightmap[tr][tq] = diff;
                            }
                        }
                    }
                }
            }*/

            let lights = [];

            for (let building of this.buildings) {
                if (building.lightlevel) {
                    lights.push({ ...building.qr, light: building.lightlevel });
                }
            }

            for (let entity of game.entities) {
                if (entity.lightlevel) {
                    lights.push({ ...xy2qr(entity.pos), light: entity.lightlevel });
                }
            }

            this.lightmap = floodlight(this.tiles, lights);
            for (let r = 0; r < this.lightmap.length; r++) {
                for (let q = 0; q < this.lightmap[0].length; q++) {
                    if (this.lightmap[r][q] > this.fogofwar[r][q]) {
                        this.fogofwar[r][q] = 1;
                    }
                }
            }
        },

        pathToTarget(from, to) {
            let qrFrom = xy2qr(from);
            let qrTo = xy2qr(to);

            let dist = manhattan(qrFrom, qrTo);
            if (dist <= 1) {
                return to;
            }

            let key = [qrTo.q, qrTo.r].join(',');

            // Our game doesn't support any kinds of doors or world destruction or
            // anything like that, so once we've calculated a field we don't need to
            // recalculate it.
            let field = this.cachedFields[key];
            if (!field) {
                field = this.cachedFields[key] = flood(this.tiles, qrTo);
            }

            let options = [
                [qrFrom.q + 1, qrFrom.r],
                [qrFrom.q - 1, qrFrom.r],
                [qrFrom.q, qrFrom.r + 1],
                [qrFrom.q, qrFrom.r - 1]
            ];

            for (let option of options) {
                option.push(field[option[1]][option[0]]);
            }
            options.sort((a, b) => a[2] - b[2]);

            return centerxy(qr2xy({ q: options[0][0], r: options[0][1] }));
        },

        makePrettyWalls() {
            for (let r = 0; r < this.tiles.length; r++) {
                for (let q = 0; q < this.tiles[0].length; q++) {
                    if (this.tiles[r][q] === TILE_CORNER_INNER) {
                        let bitmask = 0;

                        if ((this.tiles[r - 1]?.[q - 1] || 99) < 8) bitmask |= 0b100_000_000;
                        if ((this.tiles[r - 1]?.[q] || 99) < 8)     bitmask |= 0b010_000_000;
                        if ((this.tiles[r - 1]?.[q + 1] || 99) < 8) bitmask |= 0b001_000_000;
                        if ((this.tiles[r]?.[q - 1] || 99) < 8)     bitmask |= 0b000_100_000;
                        if ((this.tiles[r]?.[q + 1] || 99) < 8)     bitmask |= 0b000_001_000;
                        if ((this.tiles[r + 1]?.[q - 1] || 99) < 8) bitmask |= 0b000_000_100;
                        if ((this.tiles[r + 1]?.[q] || 99) < 8)     bitmask |= 0b000_000_010;
                        if ((this.tiles[r + 1]?.[q + 1] || 99) < 8) bitmask |= 0b000_000_001;

                        Sprite.getDynamicTile(bitmask);
                        this.tiles[r][q] = TILE_DYNAMIC + bitmask;
                    }
                }
            }
        }
    };

    // Hud

    const TRAY_HEIGHT = 18;

    /**
     * Hud
     *
     * Health bars, ammo, etc.
     */
    const Hud = {
        init() {
            this.wipCanvas = createCanvas(7, 7);
        },

        update() {
            if (World.selected) {
                let tile = World.tileAt(World.selected);
                let building = World.buildingAt(World.selected);
                if (building) {
                    this.actions = building.hudActions();
                } else if (tile >= 1 && tile <= 4) {
                    this.actions = [MoveAction, BuildTowerAction, TeleportCoffinAction];
                } else {
                    this.actions = [];
                }
            } else {
                this.actions = [];
            }

            if (Input.dragging) {
                this.selectedAction = undefined;
            }
        },

        draw() {
            Viewport.ctx.fillStyle = rgba(36, 26, 20, 0.4);
            Viewport.ctx.fillRect(0, 0, Viewport.width, 9);
            // Glyphs

            if (game.wave) {
                if (game.wave.incoming) {
                    let text = 'WAVE ' + (game.wave.waveNumber + 1);
                    let width = Text.measureWidth(text, 1);
                    let u = (Viewport.width - width) / 2;
                    let color = Math.floor(game.frame / 60) % 2 === 0 ? Text.duotone : Text.duotone_red;
                    Text.drawText(Viewport.ctx, text, u, 2, 1, color);
                } else {
                    let seconds = Math.ceil(game.wave.countdown / 60);

                    if (seconds <= 30) {
                        let text = 'NEXT WAVE';
                        let width = Text.measureWidth(text, 1) + 2;
                        let u = (Viewport.width - width) / 2;
                        Text.drawText(Viewport.ctx, 'NEXT WAVE ', u, 2);

                        this.wipCanvas.ctx.clearRect(0, 0, 7, 7);
                        this.wipCanvas.ctx.fillStyle = rgba(255, 212, 163, 1);
                        this.wipCanvas.ctx.beginPath();
                        this.wipCanvas.ctx.moveTo(3.5, 3.5);
                        this.wipCanvas.ctx.lineTo(3.5, 0);
                        this.wipCanvas.ctx.arc(3.5, 3.5, 3, Math.PI * 1.5, Math.PI * 1.5 + (seconds / 30 * Math.PI * 2));
                        this.wipCanvas.ctx.fill();

                        Viewport.ctx.drawImage(this.wipCanvas.canvas, u + width, 1);
                    }
                }
            }

            let moths = game.entities.filter(x => x instanceof Moth);
            for (let i = 0; i < moths.length; i++) {
                Viewport.ctx.drawImage(Sprite.moth[1].img, 2 + i * 4, 2);
            }

            let cornerText = '' + game.earth + 'e ' + String(game.fervor).padStart(2) + 'f';
            let cornerWidth = Text.measureWidth(cornerText, 1);

            Viewport.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            Text.drawText(Viewport.ctx, cornerText, Viewport.width - cornerWidth - 2, 2);


            // SHOW DEBUGGING INFO
    /*
            if (Input.pointer) {
                let u = Input.pointer.u;
                let v = Input.pointer.v;
                let xy = uv2xy(Input.pointer);
                let qr = xy2qr(xy);

                Text.drawText(Viewport.ctx, '' + u + ',' + v + '. ' + xy.x + ',' + xy.y + '. ' + qr.q + ',' + qr.r + '.', Viewport.width - 100, 20);
                if (World.selected) {
                    let tile = World.tiles[World.selected.r][World.selected.q];
                    if (tile > 20) tile = tile - 20;
                    Text.drawText(Viewport.ctx, '' + World.selected.q + ',' + World.selected.r + '. ' + tile.toString(2).padStart(9, '0'), Viewport.width - 100, 29);
                }
            }
    */

            // Health
            /*
            let hp = clamp(game.player.hp, 0, 100);
            Viewport.ctx.drawImage(Sprite.hud_healthbar[0].img, 2, 2);
            Viewport.ctx.drawImage(
                Sprite.hud_healthbar[1].img,
                0,
                0,
                hp + 8,
                8,
                2,
                2,
                hp + 8,
                8
            );
            */

            // Shells
            /*let sprite = Sprite.hud_shells_full;
            for (let i = 0; i < game.player.shellsMax; i++) {
                if (i + 1 > game.player.shellsLeft)
                    sprite = Sprite.hud_shells_empty;
                Viewport.ctx.drawImage(sprite.img, 15 + 6 * i, 10);
            }*/

            // Glyphs
            // Text.drawText(Viewport.ctx, 'stuvw', Viewport.width - HUD_PAGE_TEXT_U - 60, 4, 2, Text.blue, Text.blue_shadow);

            if (World.selected) {
                /*Viewport.ctx.globalAlpha = 0.5;
                let uv = xy2uv(qr2xy(World.selected));
                Viewport.ctx.drawImage(Sprite.hud_tile_selected[Math.floor(game.frame / 30) % 2].img, uv.u, uv.v);
                Viewport.ctx.globalAlpha = 1;*/

                let uv = xy2uv(qr2xy(World.selected));
                Viewport.ctx.drawImage(Sprite.hud_select[0].img, uv.u, uv.v);
            }

            // Debugging - viewport width/height
            /*
            Text.drawRightText(
                Viewport.ctx,
                [Viewport.scale, Viewport.width, Viewport.height, 'stuvwx'].join(', '),
                Viewport.width - 4,
                Viewport.height - 18
            );
            */

            Viewport.ctx.fillStyle = '#ffd4a3';
            Viewport.ctx.fillRect(0, Viewport.height - TRAY_HEIGHT, Viewport.width, 1);

            Viewport.ctx.fillStyle = '#8d697a';
            Viewport.ctx.fillRect(0, Viewport.height - TRAY_HEIGHT + 1, Viewport.width, 1);

            Viewport.ctx.fillStyle = '#203c56';
            Viewport.ctx.fillRect(0, Viewport.height - TRAY_HEIGHT + 2, Viewport.width, TRAY_HEIGHT - 2);

            Viewport.ctx.fillStyle = '#8d697a';
            Viewport.ctx.fillRect(0, Viewport.height - 2, Viewport.width, 2);

            //Viewport.ctx.drawImage(Sprite.hud_tray_building[0].img, 0, Viewport.height - TRAY_HEIGHT + 1);

            Viewport.ctx.drawImage(Sprite.hud_tray_divider[0].img, -2, Viewport.height - TRAY_HEIGHT + 1);
            Viewport.ctx.drawImage(Sprite.hud_tray_divider[0].img, 64, Viewport.height - TRAY_HEIGHT + 1);
            Viewport.ctx.drawImage(Sprite.hud_tray_divider[0].img, Viewport.width - 3, Viewport.height - TRAY_HEIGHT + 1);

            if (World.selected) {
                let building = World.buildingAt(World.selected);
                if (building) {
                    Viewport.ctx.drawImage(building.portraitSprite.img, 3, Viewport.height - TRAY_HEIGHT - 1);

                    Text.drawParagraph(
                        Viewport.ctx,
                        building.title,
                        14,
                        Viewport.height - TRAY_HEIGHT + 3,
                        Viewport.width
                    );
                } else {
                    let tile = World.tileAt(World.selected);
                    Viewport.ctx.drawImage(Sprite.tile_background[1].img, 4, Viewport.height - TRAY_HEIGHT + 6);
                    Viewport.ctx.drawImage(Sprite.tiles[tile - 1].img, 3, Viewport.height - TRAY_HEIGHT + 5);
                    Text.drawParagraph(
                        Viewport.ctx,
                        TILE_DESCRIPTIONS[tile - 1],
                        14,
                        Viewport.height - TRAY_HEIGHT + 3,
                        Viewport.width
                    );
                }
            }

            let selectedActionIndex;

            for (let i = 0; i < this.actions.length; i++) {
                let action = this.actions[i];
                let uvAction = this.uvTrayAction(i);
                Viewport.ctx.drawImage(Sprite.hud_tray_divider[0].img, uvAction.u + 11, Viewport.height - TRAY_HEIGHT + 1);
                Viewport.ctx.drawImage(action.buttonSprite().img, uvAction.u, uvAction.v);

                if (this.selectedAction === action) selectedActionIndex = i;
            }

            if (selectedActionIndex >= 0) {
                let uvAction = this.uvTrayAction(selectedActionIndex);

                Viewport.ctx.drawImage(Sprite.hud_tray_popup[0].img, uvAction.u - 23, uvAction.v - 19);

                Viewport.ctx.drawImage(this.selectedAction.buttonSelectedSprite().img, uvAction.u, uvAction.v);

                this.selectedAction.drawSelectedText(uvAction.u - 23 + 3, uvAction.v - 19 + 3);
            }

            if (Input.pointer) {
                if (game.dialog) {
                    Viewport.ctx.globalAlpha = 0.5;
                }
                //Sprite.drawViewportSprite(Sprite.hud_crosshair[0], uv2xy(Input.pointer), game.frame / 72);
                Sprite.drawViewportSprite(Sprite.hud_mouse, uv2xy(Input.pointer));
                Viewport.ctx.globalAlpha = 1;
            }

            /*
            Visual Effect Warning
            let gorp = game.frame % 60;
            let x = (gorp / 60) * (Viewport.width + 100) - 50;

            Viewport.ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
            Viewport.ctx.beginPath();
            Viewport.ctx.moveTo(x + 20, 0);
            Viewport.ctx.lineTo(x +0, Viewport.height);
            Viewport.ctx.lineTo(x+40, Viewport.height);
            Viewport.ctx.lineTo(x+60, 0);
            Viewport.ctx.closePath();
            Viewport.ctx.fill();
            */
        },

        uvTrayAction(i) {
            return { u: 68 + i * 15, v: Viewport.height - 15 };
        },

        tap(uv) {
            if (uv.v > Viewport.height - TRAY_HEIGHT) {
                for (let i = 0; i < this.actions.length; i++) {
                    let uvAction = this.uvTrayAction(i);
                    if (uv.u >= uvAction.u && uv.u <= uvAction.u + 12 && uv.v >= uvAction.v && uv.v <= uvAction.v + 12) {
                        if (this.actions[i] === this.selectedAction) {
                            if (this.selectedAction.tap()) {
                                this.selectedAction = undefined;
                            }
                        } else {
                            this.selectedAction = this.actions[i];
                        }
                        return true;
                    }
                }

                this.selectedAction = undefined;
                return true;
            }

            this.selectedAction = undefined;
            return false;
        }
    };

    // Camera

    const Camera = {
        init() {
            this.pos = { x: 0, y: 0 };
            this.forceTarget = undefined;
            this.vel = { x: 0, y: 0 };
        },

        update() {
            if (this.forceTarget) {
                let dist = vectorBetween(this.pos, this.forceTarget);

                if (dist.m < 1) {
                    this.forceTarget = undefined;
                    return;
                }

                dist.m = clamp(dist.m, 0, 2);

                let newVelocity = vector2point(dist);
                this.vel = {
                    x: (this.vel.x + newVelocity.x) / 2,
                    y: (this.vel.y + newVelocity.y) / 2
                };

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
            }

            if (Input.pressed[Input.Action.RAW_TOUCH]) {
                this.dragStart = { ...this.pos };
            }

            if (Input.dragging) {
                this.pos = {
                    x: this.dragStart.x - Input.dragVector.x,
                    y: this.dragStart.y - Input.dragVector.y
                };
            }

            //this.pos = Game.player.pos;
            //this.pos = { x: 0, y: 0, z: 0 };
        }
    };

    function normalizeVector(p) {
        let m = Math.sqrt(p.x * p.x + p.y * p.y);
        return m === 0 ? { x: 0, y: 0, m: 0 } : { x: p.x / m, y: p.y / m, m };
    }

    function vectorBetween(p1, p2) {
        return normalizeVector({ x: p2.x - p1.x, y: p2.y - p1.y });
    }

    function angle2vector(r, m) {
        return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };
    }

    function vector2point(v) {
        return { x: v.x * (v.m || 1), y: v.y * (v.m || 1) };
    }

    // Takes a series of vectors and denormalizes them and adds them together, usually resulting
    // in a point in space. Wrap in normalizeVector to get a normalized vector again, if desired.
    function vectorAdd(...vectors) {
        let v = { x: 0, y: 0, m: 1 };
        for (let vector of vectors) {
            v.x += vector.x * (vector.m || 1);
            v.y += vector.y * (vector.m || 1);
        }
        return v;
    }

    function xy2qr(pos) {
        return { q: (pos.x / TILE_SIZE) | 0, r: (pos.y / TILE_SIZE) | 0 };
    }

    function qr2xy(pos) {
        return { x: pos.q * TILE_SIZE, y: pos.r * TILE_SIZE };
    }

    function xy2uv(pos) {
        return {
            u: pos.x + Viewport.center.u - Camera.pos.x,
            v: pos.y + Viewport.center.v - Camera.pos.y
        };
    }

    function uv2xy(pos) {
        return {
            x: pos.u - Viewport.center.u + Camera.pos.x,
            y: pos.v - Viewport.center.v + Camera.pos.y
        };
    }

    function centerxy(pos) {
        return {
            x: pos.x + TILE_SIZE / 2,
            y: pos.y + TILE_SIZE / 2
        };
    }

    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }

    function manhattan(qr1, qr2) {
        return Math.abs(qr1.q - qr2.q) + Math.abs(qr1.r - qr2.r);
    }

    /**
     * @param {XY[]} bounds  the upper-left and lower-right bounds
     * @yields {QR}
     */
    function* tilesHitInBounds(bounds) {
        for (let r = bounds[0].y / TILE_SIZE | 0; r * TILE_SIZE < bounds[1].y; r++) {
            for (let q = bounds[0].x / TILE_SIZE | 0; q * TILE_SIZE <  bounds[1].x; q++) {
                yield { q, r };
            }
        }
    }

    /**
     * @param {XY} p1  the starting position
     * @param {XY} p2  the ending position
     * @param {number} r  the radius of the moving circle
     * @yields {QR}
     */
    function* tilesHitBetweenCircle(p1, p2, r) {
        let bounds = [
            { x: Math.min(p1.x, p2.x) - r, y: Math.min(p1.y, p2.y) - r },
            { x: Math.max(p1.x, p2.x) + r, y: Math.max(p1.y, p2.y) + r }
        ];
        yield* tilesHitInBounds(bounds);
    }

    /**
     * @param {XY} p  the starting position
     * @param {XY} v  the velocity (movement)
     * @param {number} r  the radius of the moving circle
     * @yields {QR}
     */
    function* tilesHitByCircle(p, v, r) {
        yield* tilesHitBetweenCircle(p, { x: p.x + v.x, y: p.y + v.y }, r);
    }

    // See https://stackoverflow.com/a/18790389/80630
    function intersectCircleRectangle(p1, p2, r, bounds) {
        // If the bounding box around the start and end points (+radius on all
        // sides) does not intersect with the rectangle, definitely not an
        // intersection
        if (
            Math.max(p1.x, p2.x) + r < bounds[0].x ||
            Math.min(p1.x, p2.x) - r > bounds[1].x ||
            Math.max(p1.y, p2.y) + r < bounds[0].y ||
            Math.min(p1.y, p2.y) - r > bounds[1].y
        )
            return;

        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let invdx = dx === 0 ? 0 : 1 / dx;
        let invdy = dy === 0 ? 0 : 1 / dy;
        let cornerX = Infinity;
        let cornerY = Infinity;

        // Check each side of the rectangle for a single-side intersection
        // Left Side
        if (p1.x - r < bounds[0].x && p2.x + r > bounds[0].x) {
            let ltime = (bounds[0].x - r - p1.x) * invdx;
            if (ltime >= 0 && ltime <= 1) {
                let ly = dy * ltime + p1.y;
                if (ly >= bounds[0].y && ly <= bounds[1].y) {
                    return {
                        x: dx * ltime + p1.x,
                        y: ly,
                        t: ltime,
                        nx: -1,
                        ny: 0,
                        ix: bounds[0].x,
                        iy: ly
                    };
                }
            }
            cornerX = bounds[0].x;
        }
        // Right Side
        if (p1.x + r > bounds[1].x && p2.x - r < bounds[1].x) {
            let rtime = (p1.x - (bounds[1].x + r)) * -invdx;
            if (rtime >= 0 && rtime <= 1) {
                let ry = dy * rtime + p2.y;
                if (ry >= bounds[0].y && ry <= bounds[1].y) {
                    return {
                        x: dx * rtime + p1.x,
                        y: ry,
                        t: rtime,
                        nx: 1,
                        ny: 0,
                        ix: bounds[1].x,
                        iy: ry
                    };
                }
            }
            cornerX = bounds[1].x;
        }
        // Top Side
        if (p1.y - r < bounds[0].y && p2.y + r > bounds[0].y) {
            let ttime = (bounds[0].y - r - p1.y) * invdy;
            if (ttime >= 0 && ttime <= 1) {
                let tx = dx * ttime + p1.x;
                if (tx >= bounds[0].x && tx <= bounds[1].x) {
                    return {
                        x: tx,
                        y: dy * ttime + p1.y,
                        t: ttime,
                        nx: 0,
                        ny: -1,
                        ix: tx,
                        iy: bounds[0].y
                    };
                }
            }
            cornerY = bounds[0].y;
        }
        // Bottom Side
        if (p1.y + r > bounds[1].y && p2.y - r < bounds[1].y) {
            let btime = (p1.y - (bounds[1].y + r)) * -invdy;
            if (btime >= 0 && btime <= 1) {
                let bx = dx * btime + p1.x;
                if (bx >= bounds[0].x && bx <= bounds[1].x) {
                    return {
                        x: bx,
                        y: dy * btime + p1.y,
                        t: btime,
                        nx: 0,
                        ny: 1,
                        ix: bx,
                        iy: bounds[0].y
                    };
                }
            }
            cornerY = bounds[1].y;
        }

        // If we haven't touched anything, there is no collision
        if (cornerX === Infinity && cornerY === Infinity) return;

        // We didn't pass through a side but may be hitting the corner
        if (cornerX !== Infinity && cornerY === Infinity) {
            cornerY = dy > 0 ? bounds[1].y : bounds[0].y;
        }
        if (cornerY !== Infinity && cornerX === Infinity) {
            cornerX = dx > 0 ? bounds[1].x : bounds[0].x;
        }

        /* Solve the triangle between the start, corner, and intersection point.
         *
         *           +-----------T-----------+
         *           |                       |
         *          L|                       |R
         *           |                       |
         *           C-----------B-----------+
         *          / \
         *         /   \r     _.-E
         *        /     \ _.-'
         *       /    _.-I
         *      / _.-'
         *     S-'
         *
         * S = start of circle's path
         * E = end of circle's path
         * LTRB = sides of the rectangle
         * I = {ix, iY} = point at which the circle intersects with the rectangle
         * C = corner of intersection (and collision point)
         * C=>I (r) = {nx, ny} = radius and intersection normal
         * S=>C = cornerdist
         * S=>I = intersectionDistance
         * S=>E = lineLength
         * <S = innerAngle
         * <I = angle1
         * <C = angle2
         */
        let inverseRadius = 1 / r;
        let lineLength = Math.sqrt(dx * dx + dy * dy);
        let cornerdx = cornerX - p1.x;
        let cornerdy = cornerY - p1.y;
        let cornerDistance = Math.sqrt(cornerdx * cornerdx + cornerdy * cornerdy);
        let innerAngle = Math.acos(
            (cornerdx * dx + cornerdy * dy) / (lineLength * cornerDistance)
        );

        // If the circle is too close, no intersection
        if (cornerDistance < r) return;

        // If inner angle is zero, it's going to hit the corner straight on.
        if (innerAngle === 0) {
            let time = (cornerDistance - r) / lineLength;

            // Ignore if time is outside boundaries of (p1, p2)
            if (time > 1 || time < 0) return;

            let ix = time * dx + p1.x;
            let iy = time * dy + p1.y;
            let nx = cornerdx / cornerDistance;
            let ny = cornerdy / cornerDistance;

            return isNaN(ix)
                ? undefined
                : { x: ix, y: iy, t: time, nx, ny, ix: cornerX, iy: cornerY };
        }

        let innerAngleSin = Math.sin(innerAngle);
        let angle1Sin = innerAngleSin * cornerDistance * inverseRadius;

        // If the angle is too large, there is no collision
        if (Math.abs(angle1Sin) > 1) return;

        let angle1 = Math.PI - Math.asin(angle1Sin);
        let angle2 = Math.PI - innerAngle - angle1;
        let intersectionDistance = (r * Math.sin(angle2)) / innerAngleSin;
        let time = intersectionDistance / lineLength;

        // Ignore if time is outside boundaries of (p1, p2)
        if (time > 1 || time < 0) return;

        let ix = time * dx + p1.x;
        let iy = time * dy + p2.y;
        let nx = (ix - cornerX) * inverseRadius;
        let ny = (iy - cornerY) * inverseRadius;

        return isNaN(ix)
            ? undefined
            : { x: ix, y: iy, t: time, nx, ny, ix: cornerX, iy: cornerY };
    }

    // https://stackoverflow.com/questions/18683179/how-to-fix-circles-overlap-in-collision-response
    //
    // This is an incredibly simple implementation that ASSUMES very small velocities. It doesn't attempt
    // to answer the question about "when" the intersection happened like the method above - may
    // fix that in future.
    function intersectCircleCircle(p1, r1, v1, p2, r2, v2) {
        [v1, v2] = [vector2point(v1), vector2point(v2)];
        let a1 = { x: p1.x + v1.x, y: p1.y + v1.y };
        let a2 = { x: p2.x + v2.x, y: p2.y + v2.y };
        let delta = vectorBetween(a1, a2);
        if (delta.m < r1 + r2) {
            return { nx: delta.x, ny: delta.y, m: r1 + r2 - delta.m };
        }
    }

    function flood(maze, to, maxDistance = Infinity) {
        let result = array2d(maze[0].length, maze.length, () => Infinity);
        let stack = [{ ...to, cost: 0 }];
        while (stack.length > 0) {
            let { q, r, cost } = stack.shift();
            if (result[r][q] <= cost) continue;
            result[r][q] = cost++;
            if (result[r][q] >= maxDistance) continue;
            if (tileIsPassable(q + 1, r) && result[r][q + 1] > cost)
                stack.push({ q: q + 1, r, cost });
            if (tileIsPassable(q - 1, r) && result[r][q - 1] > cost)
                stack.push({ q: q - 1, r, cost });
            if (tileIsPassable(q, r + 1) && result[r + 1][q] > cost)
                stack.push({ q, r: r + 1, cost });
            if (tileIsPassable(q, r - 1) && result[r - 1][q] > cost)
                stack.push({ q, r: r - 1, cost });
        }
        return result;
    }

    function floodlight(maze, froms, maxDistance = Infinity) {
        let result = array2d(maze[0].length, maze.length, () => 0);
        let stack = [...froms];

        while (stack.length > 0) {
            let { q, r, light } = stack.shift();
            if (result[r][q] >= light) continue;
            result[r][q] = light--;
            if (result[r][q] >= maxDistance) continue;
            if (tileOnMap(q + 1, r) && result[r][q + 1] < light)
                stack.push({ q: q + 1, r, light });
            if (tileOnMap(q - 1, r) && result[r][q - 1] < light)
                stack.push({ q: q - 1, r, light });
            if (tileOnMap(q, r + 1) && result[r + 1][q] < light)
                stack.push({ q, r: r + 1, light });
            if (tileOnMap(q, r - 1) && result[r - 1][q] < light)
                stack.push({ q, r: r - 1, light });
        }
        return result;
    }

    function array2d(width, height, fn) {
        return Array.from({ length: height }, () =>
            Array.from({ length: width }, fn)
        );
    }

    function tileOnMap(q, r) {
        let tiles = World.floors[0].tiles;
        if (q < 0 || r < 0 || r >= tiles.length || q >= tiles[r].length) {
            return false;
        }
        return true;
    }

    function tileIsPassable(q, r) {
        let tiles = World.floors[0].tiles;
        if (q < 0 || r < 0 || r >= tiles.length || q >= tiles[r].length) {
            return false;
        }
        if (tiles[r][q] >= 1 && tiles[r][q] <= 4) {
            return true;
        }

        return false;
    }

    function rgba(r, g, b, a) {
        return `rgba(${r},${g},${b},${a})`;
    }

    function createCanvas(width, height) {
        let canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        let ctx = canvas.getContext('2d');
        return { canvas, ctx };
    }

    /**
     * This module is generated by `gulp buildAssets`.
     */
    const SpriteSheet =
        /* <generated> */
    { attack: [ [ 0, 0, 10, 10 ], [ 10, 0, 10, 10 ] ],
      buildings:
       [ [ 0, 10, 8, 16 ],
         [ 8, 10, 8, 16 ],
         [ 16, 10, 8, 16 ],
         [ 24, 10, 8, 16 ],
         [ 32, 10, 8, 16 ] ],
      bullet1: [ [ 0, 26, 3, 3 ] ],
      buttons:
       [ [ 0, 29, 12, 12 ],
         [ 12, 29, 12, 12 ],
         [ 24, 29, 12, 12 ],
         [ 36, 29, 12, 12 ],
         [ 48, 29, 12, 12 ],
         [ 60, 29, 12, 12 ],
         [ 72, 29, 12, 12 ],
         [ 84, 29, 12, 12 ],
         [ 96, 29, 12, 12 ],
         [ 108, 29, 12, 12 ] ],
      cursor: [ [ 0, 41, 10, 8 ] ],
      enemy_healthbar:
       [ [ 0, 49, 9, 9 ],
         [ 9, 49, 9, 9 ],
         [ 18, 49, 9, 9 ],
         [ 27, 49, 9, 9 ],
         [ 36, 49, 9, 9 ],
         [ 45, 49, 9, 9 ],
         [ 54, 49, 9, 9 ],
         [ 63, 49, 9, 9 ] ],
      font: [ [ 0, 58, 180, 12 ] ],
      ghost:
       [ [ 0, 70, 9, 9 ],
         [ 9, 70, 9, 9 ],
         [ 18, 70, 9, 9 ],
         [ 27, 70, 9, 9 ],
         [ 36, 70, 9, 9 ],
         [ 45, 70, 9, 9 ] ],
      gore: [ [ 0, 79, 5, 5 ], [ 5, 79, 5, 5 ], [ 10, 79, 5, 5 ], [ 15, 79, 5, 5 ] ],
      hud_select: [ [ 0, 84, 9, 9 ] ],
      hud_tray_building: [ [ 0, 93, 13, 16 ] ],
      hud_tray_divider: [ [ 0, 109, 5, 16 ] ],
      hud_tray_popup: [ [ 0, 125, 60, 18 ] ],
      hud_wip:
       [ [ 0, 143, 7, 7 ],
         [ 7, 143, 7, 7 ],
         [ 14, 143, 7, 7 ],
         [ 21, 143, 7, 7 ],
         [ 28, 143, 7, 7 ],
         [ 35, 143, 7, 7 ],
         [ 42, 143, 7, 7 ],
         [ 49, 143, 7, 7 ] ],
      moth: [ [ 0, 150, 3, 3 ], [ 3, 150, 3, 3 ], [ 6, 150, 3, 3 ] ],
      tile_background: [ [ 0, 153, 8, 8 ], [ 8, 153, 8, 8 ] ],
      tiles:
       [ [ 0, 161, 8, 8 ],
         [ 8, 161, 8, 8 ],
         [ 16, 161, 8, 8 ],
         [ 24, 161, 8, 8 ],
         [ 32, 161, 8, 8 ],
         [ 40, 161, 8, 8 ],
         [ 48, 161, 8, 8 ],
         [ 56, 161, 8, 8 ],
         [ 64, 161, 8, 8 ],
         [ 72, 161, 8, 8 ],
         [ 80, 161, 8, 8 ],
         [ 88, 161, 8, 8 ],
         [ 96, 161, 8, 8 ],
         [ 104, 161, 8, 8 ] ],
      base64:
       'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAACpCAYAAACChRd3AAAAAXNSR0IArs4c6QAAC6pJREFUeJzt3U9sFNcBBvBv1jYYU/wPr6E1B5CQqzUQt1I5oKJUFKFKOfSS4hxqOBdZRMVRoiqX0ksuVUxURFNFPWFyiGkuPeRikagFKapKD05cW0JR8MGujG1sMMJALPx6WL/x27dvZt54d/bPm+8nWbM78/bN7O43b97MPu9iIpsVIHLJRDYrrvT0RAbbpgxR1V3p6RET2aywCTZbdKoLDDW5wFPvqEH9fMcOXJqb84ofslW2f3ExcDlRNWTUO5/v2OHf/vl334U+sH9x0WNLTbWmINCX5uY8NdRRXQ+GmupCnP40wD411QkZbNuySW8PUVmwBSYiIiIiIiIiIqqkorEYYnJUeEfPlXWMxm9/fQmzT56Jvq49XtvOJjx+sY6ppSfiwJ5d3gcfXynnqijlCj76FpOjAlPj+WkZtTQ14ERPJ9p2NgkAom1nkzjR04mWpoZyroYIjZVYSa5jHQvPd+BAy2OvKbOB9Y0MZtfaRK5jvRKrpxQpCPTEp5+h//XXMPHpZwWFxNh5oHUfsPpgq+Vu3edh9QG8geuRK+lufopj7QsA4D/+h63LePB8d4mbT1TID7QYOy8mptf9MIux88IbuJ7vS8sw951B6xvXsfrJeWBqXKB1n1Vfuze7hsdPgK6OjNfQALx8CSytbIje7JpfZuWvg2hvzYiHKxve3o6MeLS64bW3Zqx2GCKpoIXuf/01YGq8uJQSZgCFod48sXz/wrvobn6Khee7xfCpWcwvvvS+P/QxAKC9NYODBzKA0kL37G/Ao9UNfxXtrRkxMb2O/lyTP4XhpJUoTCa6CICWDg9T4/kQAzLM+fnIh7k3u4aF57vF6f33MTGd7xuLsXz59lZ/NZ7yp84HANyaP4SJ6XXcmj9U4tOitLIL9NpK6Pzu5qe4t9gihk/N+ov2ZxvE/OJL/RFC+Stwb2GXN3xqFrfmD2H41CzuLexi60yxbTWdsr8ccF+SrbRKbZn7c00A4LfSmoIWWtXb/cwP9b2FXV5v9zP2nym2gj506Acqrfu8zT7z1v3VBwCAnx7/1mvY/QJ7N4DF7z1Bd28TROcaNgpr8ADAG7guuyL6DuTPZ5ipJMu3P/pztbeBqBwym2G+wFCTMxhmcoXfjxVj50PHb+gniVHjPfT+OOuvbv1p0QjkX8yzN1pCC6qfHIrJUTFybTq8vDJqj/VXt/408WxeTOnm4BrQdwZRL6Y0PJQDpsbhWv03B9eM6wyqf3goZ1xn2PbfHNwaFiCXh23/8FDOvy2XDw/lUtdSGz9YkS+m+qKGkS+m+qLasK1fX08116HWZ1O3Wp/t9st6C4JssQ41yGllHD569kZLYCtkMnJtOrAVUpnemLD1mN6YqPXo64h6Dvo6bFvvpMntlu9FFLnd8r1Iq8Dx0LZhlmyCkESdpnXEaZXjBEBtOdWjWNQOqa7DZsdX641zlEx7mAGly1GpbkbSKtGNScLNwTX/T99BTDvM8FDO/9N3kFo5ylSDH2hTNyMs5KZuRlTI1TfNZgdS3zSbHch0IhXGdCJVLVEnhrqoE8O0KuhymFqGsEOqqWUIO6Sa6gsLnqm+OF2bOOcAtnUnRe9i2PT91S5GtXfIWhE5fLTc/d4k+9Fnb7TEqn/k2nTs+m3mqfXbzFPrqaedsBZZX9i/ObiGOBf21WugrL+69acJP/pOSf2pIZam+N3P5Iz8f64y1OSI/Enh/H8YanLC1lUOhpoc4F+HTu1JBBEREREREREREREREREREVHt8ADgSk9P4KCkS3Nz/n9JfPCL30WWAQBTOb2MqZypjF4uqIxaLqyMLBdVBuD4FicIIRIdcZd0/XEJhTpPXx52X5+GPSZqfab7lRb2fKOW68/P5vUwTYO2yba8cWOTUO03SxcUyKByYY8LK2ez3rB6KsV2u7b7/G1fx7jbJdn9aFAZeZ5X04dx0/YJIYScLwOvlov7JurrU+uT90t9HqUwbb/+uoS9j3Gev81yU/mg9RcFutYDZ5JkAPQXz9sk1ynvBy2X89T7+g5iKp/U87FhCm/cnTTsvv74ODtH0PZIRd9tF5b+WhS1vTbPx7YF0YMcVVZ9TFB5fXlU/dVgOoLoRyjTEcv0HOIegaJev6j1EdU3Uyc77PCy3eV6/ab1lmtq2gaqDv29CMpOnIyFyZgKq4cF2dyrZbazXD1kqdNy0/u0FC1ueOJ2GfSumhpY/b3Suxc2O4BqW1c59JWGLY/bZwqqT94O6sPF2T7aEhSQqCNq3HXoJ8H6OYMU1ODZnpNkTA+OYtqr9OVBLbaNsLL6EUF/ARjmeDyFPj9sast0BJfzZX2mLklQFySoPimyhY7aI6KeoNwYm7NUtT61/HZexFKPCmkWFO6g+1F1RR1B9dt6Hkxl2WgR1bqJbFaYpkTWJrJZIf+SrEd+LZk+VR8vlqaEaVrKdpFDxNKUkH+m5TI08i8sjLVUD6VQuVrEWquH0qXgKkdQeFSvTP+jYEpUSxIZPlquHYM7GMVVPHy0q89TpyZf5X7mT/sXF83Xp2usHqIi6lWJUvqqtVYPERERVc3/gMBDuLrs0eH87bc7IQbbgh9DVAn+SaEe4HfagH8ZQr18+yPxTlv+9mAbxFcvtkJNVHf0VniwDYKtMzljsA3ilWaPYaaaIL8O65PAAkfPvVG5zSEqjbcZ5j+GlHmboaZ6UfFvTiJKEgNNTmGgySkMNDmFgSanMNDkFF6HJqd47194N/anfG99+B4H0VNN8r8f+su5ZdxdXg4s+JPOTpzo6azIRhFtVwaIDjMA3F1expdz4WWIqi0DIDLMkm05omrhVQ5yCgNNTmGgySkMNDmFgSanMNDkFAaanMJAk1MYaHJKBsiP07BhW46oWjIAcKKnMzKsHJxE9cAfbXeih4Gl+tdomsnxzlSvMvqQUA4RpXqWUcc524yLJqplBeOhGWaqd7wOTU5hoMkpDDQ5hYEmpzDQ5BQGmpzCQJNTGGhyCgNNTikYD83xzlTvGtVxznI6U80tIipBRh8DzTHRVM/kF56n4pdgvaPnOM7bcY1iclSMXJuu9nZUhJgcFQy12/z/WLn69TfV3I7EXTx2uNqbQBXAy3bkFAaanMJAk1MYaHIKA01OYaDJKQw0OYWBJqcw0OQUBpqcwkCTUxhockqjd/ScJyZHBa4lswLbL4BM+gvVh4dyHD6aAo1AfpxwEmOitzMsdXgoV+7NAMCx0GmR+Jv8q1/+Rti20H/7+18YOipJQYDE0pQAAK+rryhY9bBMzg96HLnPeFKoBqOWlunlbJdRehgDHdW6VSPUcrkpuEGPZajTp+hHg6p5qGYAqVQFgQ4Lc9SyuGFkeCkJZftgRQbeZqcwhdnr6vOCHlvKMpttJ3ck/oZv54pEEssoheSHK2n54hlylBrgoNtEdY2tNdUj7/APukID+6Djx6EVPPnvOPuqVDM4fJScwkCTUxhocgoDTU5hoMkpDDQ5hYEmp3h7jpxJ9QcnUdfR9xw5Iy6/ehxA/lcOZu6MefryuPUfPDkg5C8KXP7nv6HXry8vZfvTphEA9nZ0GH+j8O7yMh6urJS8PGl7OzoCl5Vj/af330d/rglXvy5edvnV4zi9/z4AoD/XhJEvDhTc9wbC6wSKd5aZO2PeVWyF+vZAl7F+APjR70t+ek4p+OFNXdQPctoud11/rmkznOb7UUwt/8ydMU/93Ru9fn0e5RX9x0qQu8vLNR1QeaTQp+UQFpyrX3+jtdz6/fA6TWGWZu6MeXuOnBGy7KE/Pffrv/9ms+3mp4p1oOsxzOXq7ox8cWDzVvEvhQWF0bbOmTvvRT5eXb/sY2/NI5V1oGudDK8+jXLw5EDoSd3DlZXQPvR2bdU5IKJ2CnX9cnvlvLc+LN82uSBWoON0O2y+XKYWXDx2OPSkrvUPya//KsyhPnhyQMgdc2J6HfffbC46KaRCGSA4fHK+nOph1pfr8ytxhaMcok7qkjj5Uuu8eOxw0ZFCvXRX6klnmvwfA2NBppynO+YAAAAASUVORK5CYII=' };
    /* </generated> */

    /**
     * Sprite
     *
     * Encapsulates loading sprite slices from the spritesheet, organizing them, and
     * modifying them or constructing using primitives. To save space, we use some techniques
     * like storing only a small slice of an image in the spritesheet, then using code
     * to duplicate it, add some randomness, etc.
     */
    const Sprite = {
        // This is an exception to the rule, loading the spritesheet is a special action that
        // happens BEFORE everything is initialized.
        loadSpritesheet(cb) {
            let image = new Image();
            image.onload = cb;
            image.src = SpriteSheet.base64;
            Sprite.sheet = image;
        },

        init() {
            // Base pixel font and icons (see `Text.init` for additional variations)
            Sprite.font = initBasicSprite(SpriteSheet.font[0]);
            //Sprite.icon_mouse_lmb = initBasicSprite(SpriteSheet.icon_mouse[0]);
            //Sprite.icon_mouse_rmb = initBasicSprite(SpriteSheet.icon_mouse[1]);

            // Enemies
            //Sprite.stabguts = SpriteSheet.stabguts.map(initBasicSprite);
            //Sprite.spindoctor = SpriteSheet.spindoctor.map(initBasicSprite);

            Sprite.moth = SpriteSheet.moth.map(initBasicSprite);

            // Gore/blood
            Sprite.gore = SpriteSheet.gore.map(initBasicSprite);

            // GUI
            //Sprite.hud_healthbar = SpriteSheet.hud_healthbar.map(initBasicSprite);
            //Sprite.hud_healthbar.push(initDynamicSprite(createHealthChunk(Sprite.hud_healthbar[1].img)));
            //Sprite.hud_crosshair = SpriteSheet.hud_crosshair.map(initBasicSprite);

            Sprite.hud_mouse = SpriteSheet.cursor.map(data => initBasicSprite(data, { x: 0, y: 0 }))[0];

            Sprite.bullet1 = SpriteSheet.bullet1.map(initBasicSprite);

            Sprite.hud_tray_building = SpriteSheet.hud_tray_building.map(initBasicSprite);
            Sprite.hud_tray_divider = SpriteSheet.hud_tray_divider.map(initBasicSprite);
            Sprite.hud_tray_popup = SpriteSheet.hud_tray_popup.map(initBasicSprite);
            Sprite.hud_select = SpriteSheet.hud_select.map(initBasicSprite);

            Sprite.hud_wip = SpriteSheet.hud_wip.map(data => initBasicSprite(data, { x: -1, y: -1 }));

            // Tiles
            Sprite.tiles = SpriteSheet.tiles.map(initBasicSprite);
            Sprite.tile_background = SpriteSheet.tile_background.map(initBasicSprite);

            // Ghost enemy
            Sprite.ghost = SpriteSheet.ghost.map(initBasicSprite);

            // Buildins
            Sprite.buildings = SpriteSheet.buildings.map(data => initBasicSprite(data, { x: 0, y: 8 }));

            // Buttons
            Sprite.buttons = SpriteSheet.buttons.map(initBasicSprite);

            Sprite.tilebg = initDynamicSprite(createTileBg(Sprite.tiles[0].img));
            Sprite.shadow = initDynamicSprite(createShadow());

            Sprite.attack = SpriteSheet.attack.map(initBasicSprite);
            Sprite.enemy_healthbar = SpriteSheet.enemy_healthbar.map(initBasicSprite);

            // Dialog
            //let dialog = SpriteSheet.dialog.map(initBasicSprite);
            //Sprite.dialog_speech = initDynamicSprite(createDialogSpeech(dialog[0].img, dialog[2].img));
            //Sprite.dialog_hint = initDynamicSprite(createDialogHint(dialog[1].img));
        },

        /**
         * A small helper that draws a sprite onto a canvas, respecting the anchor point of
         * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
         * that's appropriate!
         */
        drawSprite(ctx, sprite, u, v) {
            ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
        },

        drawViewportSprite(sprite, pos, rotation) {
            let { u, v } = this.viewportSprite2uv(
                sprite,
                pos
            );
            if (rotation) {
                Viewport.ctx.save();
                Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
                Viewport.ctx.rotate(rotation);
                Viewport.ctx.drawImage(
                    sprite.img,
                    -sprite.anchor.x,
                    -sprite.anchor.y
                );
                Viewport.ctx.restore();
            } else {
                Viewport.ctx.drawImage(sprite.img, u, v);
            }
        },

        viewportSprite2uv(sprite, pos) {
            return {
                u: pos.x - sprite.anchor.x - Camera.pos.x + Viewport.center.u,
                v: pos.y - sprite.anchor.y - Camera.pos.y + Viewport.center.v
            };
        },

        getDynamicTile(bitmask) {
            if (!this.tiles[bitmask + TILE_DYNAMIC - 1]) {
                this.tiles[bitmask + TILE_DYNAMIC - 1] = initDynamicSprite(createDynamicTile(this.tiles, bitmask), { x: 0, y: 0 });
            }

            return this.tiles[bitmask + TILE_DYNAMIC - 1];
        }
    };

    // Sprite utility functions

    function initBasicSprite(data, anchor) {
        return initDynamicSprite(loadCacheSlice(...data), anchor);
    }

    function initDynamicSprite(source, anchor) {
        let w = source.width,
            h = source.height;

        return {
            img: source,
            // Hack! Using a flat `.map(initBasicSprite)` is actually going to pass the
            // element INDEX as second argument, resulting in "anchor=1". The right solution
            // here is "typeof anchor === 'object' ?", but to save bytes I avoid using
            // the typeof and instanceof keywords anywhere in the codebase. Hence,
            // "anchor && anchor.x".
            anchor: (typeof anchor === 'object') ? anchor : { x: (w / 2) | 0, y: (h / 2) | 0 }
        };
    }

    function loadCacheSlice(x, y, w, h) {
        const source = Sprite.sheet;
        const sliceCanvas = createCanvas(w, h);
        sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
        return sliceCanvas.canvas;
    }

    // Given wall tile, create a full screen tiled version to render in background
    function createTileBg(source) {
        let canvas = createCanvas(544, 334);
        for (let y = 0; y < 334; y += 32) {
            for (let x = 0; x < 544; x += 32) {
                canvas.ctx.drawImage(source, x, y);
            }
        }
        return canvas.canvas;
    }

    // "Shadow" overlay (gives flickering shadows in corners)
    function createShadow() {
        let canvas = createCanvas(500, 500);
        let gradient = canvas.ctx.createRadialGradient(
            250,
            250,
            0,
            250,
            250,
            250
        );
        gradient.addColorStop(0.3, rgba(0, 0, 0, 0));
        gradient.addColorStop(1, rgba(0, 0, 0, 0.9));
        canvas.ctx.fillStyle = gradient;
        canvas.ctx.fillRect(0, 0, 500, 500);
        return canvas.canvas;
    }

    function createDynamicTile(tiles, bitmask) {
        let canvas = createCanvas(TILE_SIZE, TILE_SIZE);

        // First, we render outer corners

        if (bitmask & 0b100_000_000) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_OUTER - 1].img, 0, 0, 4, 4, 0, 0, 4, 4);
        }
        if (bitmask & 0b001_000_000) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_OUTER - 1].img, 5, 0, 3, 3, 5, 0, 3, 3);
        }
        if (bitmask & 0b000_000_001) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_OUTER - 1].img, 6, 6, 2, 2, 6, 6, 2, 2);
        }
        if (bitmask & 0b000_000_100) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_OUTER - 1].img, 0, 5, 3, 3, 0, 5, 3, 3);
        }

        // Next we render standard walls (potentially overwriting outer corners above)

        if (bitmask & 0b000_001_000) {
            canvas.ctx.drawImage(tiles[TILE_WALL_LEFT - 1].img, 5, 0, 3, 8, 5, 0, 3, 8);
        }
        if (bitmask & 0b000_100_000) {
            canvas.ctx.drawImage(tiles[TILE_WALL_RIGHT - 1].img, 0, 0, 4, 8, 0, 0, 4, 8);
        }
        if (bitmask & 0b000_000_010) {
            canvas.ctx.drawImage(tiles[TILE_WALL_TOP - 1].img, 0, 5, 8, 3, 0, 5, 8, 3);
        }
        if (bitmask & 0b010_000_000) {
            canvas.ctx.drawImage(tiles[TILE_WALL_BOTTOM - 1].img, 0, 0, 8, 4, 0, 0, 8, 4);
        }

        // Next we render inner corners (potentially overwriting parts of walls above)

        if ((bitmask & 0b010_100_000) === 0b010_100_000) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_INNER - 1].img, 0, 0, 5, 5, 0, 0, 5, 5);
        }
        if ((bitmask & 0b010_001_000) === 0b010_001_000) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_INNER - 1].img, 4, 0, 4, 4, 4, 0, 4, 4);
        }
        if ((bitmask & 0b000_001_010) === 0b000_001_010) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_INNER - 1].img, 4, 4, 4, 4, 4, 4, 4, 4);
        }
        if ((bitmask & 0b000_100_010) === 0b000_100_010) {
            canvas.ctx.drawImage(tiles[TILE_CORNER_INNER - 1].img, 0, 4, 5, 4, 0, 4, 5, 4);
        }

        return canvas.canvas;
    }

    /**
     * Movement
     */
    const Movement = {
        perform(entities) {
            // Movement only applies to active entities with positions and velocities
            let movers = entities.filter(
                entity => entity.pos && entity.vel && !entity.cull
            );

            // Very basic "rounds" of collision resolution, since we have no real physics.
            // (As usual, "detecting" a collision is not the hard part... we need to resolve
            // them too!)
            for (let rounds = 0; rounds < 5; rounds++) {
                // Each pair of entities only needs to interact once.
                for (let i = 0; i < movers.length - 1; i++) {
                    for (let j = i + 1; j < movers.length; j++) {
                        Movement.clipVelocityEntityVsEntity(movers[i], movers[j]);
                    }
                }

                for (let entity of movers) {
                    Movement.clipVelocityAgainstWalls(entity);
                }
            }

            // Now we perform all movement, even if it's not going to be perfect.
            for (let entity of movers) {
                entity.pos.x += entity.vel.x;
                entity.pos.y += entity.vel.y;
            }
        },

        clipVelocityEntityVsEntity(entity, other) {
            if (entity.noClipEntity || other.noClipEntity) return;

            let hit = intersectCircleCircle(
                entity.pos,
                entity.radius,
                entity.vel,
                other.pos,
                other.radius,
                other.vel
            );
            if (hit) {
                if (entity.bounce && other.bounce) {
                    entity.vel.x = -hit.nx * hit.m;
                    entity.vel.y = -hit.ny * hit.m;
                    other.vel.x = hit.nx * hit.m;
                    other.vel.y = hit.ny * hit.m;
                } else {
                    // Not a bug: we "add" the mass of the opposing entity to our own velocity when deciding who
                    // is at fault for the collision. Entity velocities adjust in relation to their fault level.
                    let entityM = normalizeVector(entity.vel).m + other.mass,
                        otherM = normalizeVector(other.vel).m + entity.mass,
                        entityI = entity.bounce ? 0.1 : 1,
                        otherI = other.bounce ? 0.1 : 1;
                    entity.vel.x -=
                        (hit.nx * hit.m * entityI * entityM) / (entityM + otherM);
                    entity.vel.y -=
                        (hit.ny * hit.m * entityI * entityM) / (entityM + otherM);
                    other.vel.x +=
                        (hit.nx * hit.m * otherI * otherM) / (entityM + otherM);
                    other.vel.y +=
                        (hit.ny * hit.m * otherI * otherM) / (entityM + otherM);
                }
            }
        },

        clipVelocityAgainstWalls(entity) {
            if (entity.noClipWall) return;

            for (let tile of tilesHitByCircle(
                entity.pos,
                entity.vel,
                entity.radius
            )) {
                if (!tileIsPassable(tile.q, tile.r)) {
                    let bounds = [
                        qr2xy(tile),
                        qr2xy({ q: tile.q + 1, r: tile.r + 1 })
                    ];
                    let hit = intersectCircleRectangle(
                        entity.pos,
                        {
                            x: entity.pos.x + entity.vel.x,
                            y: entity.pos.y + entity.vel.y
                        },
                        entity.radius,
                        bounds
                    );

                    // The "math" part of detecting collision with walls is buried in the geometry functions
                    // above, but it's not the whole story -- if we do detect a collision, we still need to
                    // decide what to do about it.
                    //
                    // If the normal vector is horizontal or vertical, we zero out the portion of the vector
                    // moving into the wall, allowing frictionless sliding (if we wanted to perform friction,
                    // we could also reduce the other axis slightly).
                    //
                    // If the normal vector is not 90*, we "back up" off the wall by exactly the normal vector.
                    // If the player runs into a corner at EXACTLY a 45 degree angle, they will simply "stick"
                    // on it -- but one degree left or right and they'll slide around the corner onto the wall,
                    // which is the desired result.
                    if (hit) {
                        if (entity.bounce) {
                            if (hit.nx === 0) {
                                entity.vel.y = -entity.vel.y;
                            } else if (hit.ny === 0) {
                                entity.vel.x = -entity.vel.x;
                            } else {
                                entity.vel.x += hit.nx;
                                entity.vel.y += hit.ny;
                            }
                        } else {
                            if (hit.nx === 0) {
                                entity.vel.y = hit.y - entity.pos.y;
                            } else if (hit.ny === 0) {
                                entity.vel.x = hit.x - entity.pos.x;
                            } else {
                                entity.vel.x += hit.nx;
                                entity.vel.y += hit.ny;
                            }
                        }
                    }
                }
            }
        }
    };

    // Damage

    /**
     * Damage
     */
    const Damage = {
        perform(entities) {
            for (let entity of entities) {
                if (entity.hp) {
                    if (entity.damage.length > 0) {
                        if (entity.state !== DEAD && entity.state !== SPAWN) {
                            for (let damage of entity.damage) {
                                if (entity === game.player) {
                                    game.entities.push(
                                        new HealthChunkAnimation(
                                            entity.hp,
                                            damage.amount
                                        )
                                    );
                                }
                                entity.hp -= damage.amount;
                                damage.vector.m = damage.knockback;
                                entity.vel = vectorAdd(entity.vel, damage.vector);
                                entity.lastDamage = damage;
                                Gore.damage(entity);
                                game.entities.push(new AttackAnimation(entity.pos));
                            }
                        }
                        entity.damage = [];
                    }
                    if (entity.hp <= 0 && entity.state !== DEAD) {
                        entity.state = DEAD;
                    }
                }
            }
        }
    };

    // Wave

    const WAVES = [
        // Wave 1
        [
            [0,   0],
            [5,   0],
            [10,  0],
            [15,  0],
        ],
        // Wave 2
        [
            [0,   0],
            [1,   0],
            [2,   0],
            [3,   0],
            [10,  0],
            [11,  0],
            [12,  0],
            [15,  0],
            [15,  0],
            [15,  0],
        ],
        // Wave 3
        [
            [0,   0],
            [1,   0],
            [2,   0],
            [3,   0],
            [4,   0],
            [5,   0],
            [10,  0],
            [15,  1],
        ],
        // Wave 4
        [
            [0,   1],
            [5,   0],
            [5,   0],
            [10,  1],
            [15,  0],
            [15,  0],
            [20,  1],
        ],
        // Wave 5
        [
            [0,   1],
            [5,   0],
            [5,   0],
            [10,  0],
            [10,  0],
            [15,  0],
            [15,  1],
            [20,  2],
        ],
        // Wave 6
        [
            [0,   0],
            [1,   0],
            [2,   0],
            [3,   0],
            [4,   0],
            [5,   2],
            [6,   0],
            [7,   0],
            [8,   0],
            [9,   0],
            [10,  2],
            [15,  1],
            [19,  1],
            [20,  1],
        ],
        // Wave 7
        [
            [0,   2],
            [3,   2],
            [6,   2],
            [9,   2],
            [12,  2],
            [15,  0],
            [15,  0],
            [15,  0],
            [15,  0],
            [15,  0],
        ]
    ];

    class Wave {
        constructor(waveNumber) {
            this.waveNumber = waveNumber;

            waveNumber = waveNumber % WAVES.length;

            this.upcoming = [...WAVES[waveNumber]];
            this.countdown = 60 * 60;
            this.incoming = false;
            this.frame = 0;
            this.lastFrame = this.upcoming[this.upcoming.length - 1][0] * 60;
        }

        update() {
            this.countdown--;

            if (this.countdown >= 0 && this.countdown <= 2 * 60 && this.countdown % 60 === 0) {
                Audio.play(Audio.waveCountdown);
            }

            if (this.countdown <= 0) {
                this.incoming = true;

                for (let i = 0; i < this.upcoming.length; i++) {
                    if (this.frame === this.upcoming[i][0] * 60) {
                        game.monstersPending.push(xy => new Ghost(xy, this.upcoming[i][1]));
                    }
                }

                this.frame++;
            }

            if (this.frame >= this.lastFrame) {
                let enemies = game.entities.filter(e => e.enemy);
                if (enemies.length === 0) {
                    game.wave = undefined;
                }
            }
        }
    }

    // DefeatScreen

    class DefeatScreen {
        constructor() {
            this.frames = 0;
        }

        update() {
            this.frames++;

            if (Input.pressed[Input.Action.TAP] && this.frames > 30) {
                // Reset sequence
                game.reset();
            }

            return true;
        }

        draw() {
            //Viewport.ctx.fillStyle = rgba(13, 43, 69, clamp(this.frames / 200, 0, 1));
            Viewport.ctx.fillStyle = rgba(36, 26, 20, clamp(this.frames / 200, 0, 1));
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            let width = Viewport.width - 32;
            let x = 16;
            let y = 16;

            let message = 'DEFEAT... \n' +
                '                    \n' +
                'YOUR LAST MOTH GONE, THIS WORLD SLIPS FROM YOUR GRASP. YOU CURSE THE VILLAGE AND ITS INHABITANTS AS YOU TUMBLE TOWARDS THAT BLEAK BEYOND. \n \n'  +
                'YOUR REIGN OF TERROR HAS ENDED. \n \n' +
                'TAP TO TRY AGAIN!';

            message = message.slice(0, this.frames);

            Text.drawParagraph(
                Viewport.ctx,
                message,
                x,
                y,
                width,
                1,
                1,
                Text.duotone_red
            );
        }
    }

    // Game

    /**
     * Game state.
     */
    class Game {
        init() {
            Sprite.loadSpritesheet(() => {
                Viewport.init();
                Sprite.init();
                Text.init();
                Input.init();
                Audio.init();
                Hud.init();

                Camera.init();
                World.init();

                window.addEventListener('blur', () => this.pause());
                window.addEventListener('focus', () => this.unpause());

                this.reset();

                this.start();
            });
        }

        reset() {
            this.entities = [];
            this.dialogPending = {};
            this.dialogSeen = {};
            this.roomsCleared = {};
            this.shadowOffset = 0;
            this.screenshakes = [];
            this.monstersPending = [];
            this.waveNumber = 0;
            this.earth = 0;
            this.fervor = 0;
            this.entities.push(new Moth(qr2xy(World.spawn)));
            this.screen = undefined;
            this.wave = undefined;
            World.reset();

            Camera.pos = centerxy(qr2xy(World.exit));
            Camera.forceTarget = centerxy(qr2xy(World.spawn));
        }

        start() {
            this.frame = 0;
            this.framestamps = [0];
            this.update();
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));
        }

        onFrame(currentms) {
            let startTime= new Date().getTime();

            /*this.framestamps.push(currentms);*/
            if (this.framestamps.length >= 40) {
                this.framestamps.shift();
            }
            this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);

            this.frame++;
            Viewport.resize();
            this.update();
            this.draw(Viewport.ctx);
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));

            let endTime = new Date().getTime();
            this.framestamps.push(this.framestamps[this.framestamps.length - 1] + endTime - startTime);
        }

        update() {
            if (!this.wave) {
                this.wave = new Wave(this.waveNumber++);
            }

            // Pull in frame by frame button pushes / keypresses / mouse clicks
            Input.update();

            if (this.screen) {
                if (this.screen.update()) return;
            }

            if (Input.pressed[Input.Action.TAP]) {
                this.tap(Input.pointer);
            }

            Hud.update();

            //if (Input.pressed[Input.Action.MENU]) {
            //    this.paused ? this.unpause() : this.pause();
            //}

            if (this.paused) return;

            // Handle Input

            // End Handle Input

            // perform any per-frame audio updates
            Audio.update();

            this.wave.update();

            this.spawnMonsterIfPossible();

            // Behavior (AI, player input, etc.)
            //perform(this.entities); <-- cut to save space
            for (let entity of game.entities) {
                if (entity.think) entity.think();
            }

            // perform any queued damage
            Damage.perform(this.entities);

            // Movement (perform entity velocities to position)
            Movement.perform(this.entities);

            Camera.update();

            // Culling (typically when an entity dies)
            this.entities = this.entities.filter(entity => !entity.cull);
            World.buildings = World.buildings.filter(building => !building.cull);

            World.update();

            if (this.entities.filter(e => e instanceof Moth).length === 0) {
                game.screen = new DefeatScreen();
            }

            // Initial "click" to get game started
            // if (Input.pressed[Input.Action.ATTACK] && !game.started) game.started = true;
        }

        draw() {
            // Reset canvas transform and scale
            Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
            Viewport.ctx.scale(Viewport.scale, Viewport.scale);

            //Viewport.ctx.fillStyle = rgba(13, 43, 69, 1);
            //Viewport.ctx.fillStyle = rgba(84, 78, 104, 1);
            //Viewport.ctx.fillStyle = rgba(32, 60, 86, 1);
            Viewport.ctx.fillStyle = rgba(36, 26, 20, 1);
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            World.draw();

            for (let entity of this.entities) {
                if (!entity.z || entity.z < 100) entity.draw();
            }

            for (let entity of this.entities) {
                if (entity.z && entity.z > 100) entity.draw();
            }

            World.drawLightmap();

            Hud.draw();

            if (game.frame < 120) {
                Viewport.ctx.fillStyle = rgba(0, 0, 0, 1 - game.frame / 120);
                Viewport.fillViewportRect();
            }

            if (this.screen) {
                this.screen.draw();
            }
        }

        pause() {
            if (this.paused) return;
            this.paused = true;
            Audio.pause();
        }

        unpause() {
            if (!this.paused) return;
            this.paused = false;
            Audio.unpause();
        }

        tap(uv) {
            for (let ui of [Hud, World]) {
                if (ui.tap(uv)) break;
            }
        }

        activeMoths() {
            return this.entities.filter(x => x instanceof Moth).length;
        }

        formatCost(earth, fervor) {
            return (earth > this.earth ? 're' : 'we') + earth + (fervor > 0 ? (fervor > this.fervor ? ' rf' : ' wf') + fervor : '');
        }

        canAfford(earth, fervor) {
            return (this.earth >= earth && this.fervor >= fervor);
        }

        payCost(earth, fervor) {
            this.earth -= earth;
            this.fervor -= fervor;
        }

        spawnMonsterIfPossible() {
            let spawnFn = this.monstersPending[0];

            if (spawnFn) {
                // A spawn is attempted up to 10 times
                for (let i = 0; i < 10; i++) {
                    let q = Math.floor(Math.random() * World.floors[0].tiles[0].length);
                    let r = Math.floor(Math.random() * World.floors[0].tiles.length);
                    if (World.tiles[r][q] !== 1) {
                        continue;
                    }
                    if (World.lightmap[r][q] !== 0) {
                        continue;
                    }

                    let xy = qr2xy({ q, r });
                    game.entities.push(spawnFn(xy));
                    this.monstersPending.shift();
                    break;
                }
            }
        }
    }

    const game = new Game();

    /**
     * Create and launch game.
     */
    game.init();

})();</script>